import{_ as c}from"./plugin-vue_export-helper-c27b6911.js";import{r as p,o as i,c as l,a as n,b as s,d as a,w as u,e as t}from"./app-b3a6cb5a.js";const r="/assets/SCS程序-d21166e3.jpg",d="/assets/Binder消息通讯-2366ea3d.png",k="/assets/IDEA控制台警告-b7b62aa0.png",m={},v={href:"https://spring.io/projects/spring-cloud-stream#learn",target:"_blank",rel:"noopener noreferrer"},g=t('<h2 id="基础概念" tabindex="-1"><a class="header-anchor" href="#基础概念" aria-hidden="true">#</a> 基础概念</h2><figure><img src="'+r+'" alt="Stream 程序结构" tabindex="0" loading="lazy"><figcaption>Stream 程序结构</figcaption></figure><p>Stream 程序由一个与中间件中立的核心组成，程序通过外部 Broker 暴露的目标与代码中的 input/output 参数之间建立<strong>绑定</strong>（<strong>Bindings</strong>）来实现通信，而建立绑定的 Broker 细节则由特定于中间件的 Binder 实现处理。</p><ul><li><strong>Binder</strong>：负责提供必要的配置和实现，以促进与外部消息系统（MQ）的集成。</li><li><strong>Bindings</strong>：消息系统与 Stream 程序提供的消息生产者和使用者（由 Binder 创建）之间的桥梁，即 Producer/Consumer 与 MQ（队列、主题）之间的绑定关系。</li><li><strong>Message</strong>：Producer/Consumer 用于与 Binder（以及通过外部消息系统传递消息的其它程序）进行通讯的规范数据结构。</li></ul><figure><img src="'+d+`" alt="Binder 消息通讯" tabindex="0" loading="lazy"><figcaption>Binder 消息通讯</figcaption></figure><h2 id="BindingName" tabindex="-1"><a class="header-anchor" href="#BindingName" aria-hidden="true">#</a> Bindings 绑定</h2><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@SpringBootApplication</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SampleApplication</span> <span class="token punctuation">{</span>
    
    <span class="token annotation punctuation">@Bean</span>
    <span class="token keyword">public</span> <span class="token class-name">Consumer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Message</span><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> <span class="token function">demoConsumer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> msg <span class="token operator">-&gt;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;消息消费：&quot;</span> <span class="token operator">+</span> msg<span class="token punctuation">.</span><span class="token function">getPayload</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>一个 Stream 程序在导入<a href="#dependencies">依赖</a>后，使用上方代码即可实现消息的消息，它默认会创建以函数名称为 name 的绑定，例如 demoConsumer-in-0 。Stream 在绑定名称方面有默认的约定，在 Spring 上下文中，会检查 <code>Function</code>、<code>Supplier</code>、<code>Consumer</code> 这类 Bean 注册为消息处理器，这些消息处理器会触发绑定到所提供的 Binder 所公开的目的地（<strong>destination</strong>，即 Topic-Kafka、Exchange-RabbitMQ）。</p><p>绑定名称约定如下：</p><ul><li>input（输入绑定，即消费者）：<code>&lt;functionName&gt; + in + &lt;index&gt;</code></li><li>output（输出绑定，即生产者）：<code>&lt;functionName&gt; + out + &lt;index&gt;</code></li></ul><p><code>functionName</code> 即定义的函数式处理器 Bean 名称，<code>in/out</code> 分别对应绑定类型（输入/输出），<code>index</code> 是绑定的索引，对于单输入/输出函数，它始终为 0，它仅与<strong>具有多个输入/输出参数的函数</strong>相关。</p><p>函数的作用：</p>`,12),b=n("li",null,[n("strong",null,"Consumer"),s("：表示消息的消费，只针对消息的输入")],-1),y=n("strong",null,"Supplier",-1),h={href:"https://docs.spring.io/spring-cloud-stream/reference/spring-cloud-stream/producing-and-consuming-messages.html#polling-configuration-properties",target:"_blank",rel:"noopener noreferrer"},f={href:"https://docs.spring.io/spring-cloud-stream/reference/spring-cloud-stream/producing-and-consuming-messages.html#suppliers-sources",target:"_blank",rel:"noopener noreferrer"},S=n("li",null,[n("strong",null,"Function"),s("：表示消息的消费与生产，即输入与输出兼具 "),n("ul",null,[n("li",null,"当定义该类型时，应当有对应的输入和输出绑定"),n("li",null,[s("在默认情况下，如果定义 Function 函数，如 "),n("code",null,"public Function<String,String> toUpperCase()"),s("，会生成两个绑定 "),n("code",null,"toUpperCase-in-0"),s(" 和 "),n("code",null,"toUpperCase-out-0")])])],-1),x=t(`<p>对于绑定的目的地，可在 <code>application.yml</code> 中配置：</p><div class="language-yaml line-numbers-mode" data-ext="yml"><pre class="language-yaml"><code><span class="token comment"># 假设使用的消息系统是 RabbitMQ，此项配置会创建一个 &#39;my-topic&#39; 的 Exchange，以及一个 &#39;my-topic.my-queue&#39; 的 Queue</span>
<span class="token key atrule">spring.cloud.stream.bindings.uppercase-in-0.destination</span><span class="token punctuation">:</span> my<span class="token punctuation">-</span>topic
<span class="token key atrule">spring.cloud.stream.bindings.uppercase-in-0.group</span><span class="token punctuation">:</span> my<span class="token punctuation">-</span>queue
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="dynamic-destination" tabindex="-1"><a class="header-anchor" href="#dynamic-destination" aria-hidden="true">#</a> 消息输入/输出</h2><p><strong>StreamBridge</strong>：一个允许用户将数据发送到输出绑定的类，在 Stream 程序的常见场景中，消息是很少需要用户手动发送，即消息应当是在 Stream 程序上下文中产生并自动发送，而当数据源是在 Stream 程序之外（比如 REST 端点被调用后产生的数据要发送到目标绑定），则可使用该类进行手动发送。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@RestController</span>
<span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">&quot;/send&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SendController</span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@Resource</span>
    <span class="token keyword">private</span> <span class="token class-name">StreamBridge</span> streamBridge<span class="token punctuation">;</span>

    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">&quot;/test&quot;</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 构建消息</span>
        <span class="token class-name">Message</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> msg <span class="token operator">=</span> <span class="token class-name">MessageBuilder</span><span class="token punctuation">.</span><span class="token function">withPayload</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 向指定的目的地发送消息</span>
        streamBridge<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token string">&quot;demoConsumer-out-0&quot;</span><span class="token punctuation">,</span> msg<span class="token punctuation">,</span> <span class="token class-name">MimeType</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token string">&quot;application/json&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>首先需要说明一点，在微服务架构下，生产者和消费者一般不会在同一个服务里，因此，正常情况是会将输入绑定放在消费者服务，而在生产者服务里配置中添加一个输出绑定，并指定相应的 <code>destination</code>，如下配置。这样在生产者服务中使用 <code>StreamBridge</code> 发送消息时就指定输出绑定名称即可，会自动寻找到对应的 <code>destination</code> 进行消息路由。</p><div class="language-yaml line-numbers-mode" data-ext="yml"><pre class="language-yaml"><code><span class="token comment"># 生产者服务</span>
<span class="token key atrule">spring</span><span class="token punctuation">:</span>
  <span class="token key atrule">cloud</span><span class="token punctuation">:</span>
    <span class="token key atrule">stream</span><span class="token punctuation">:</span>
      <span class="token key atrule">bindings</span><span class="token punctuation">:</span>
        <span class="token key atrule">demoConsumer-out-0</span><span class="token punctuation">:</span>
          <span class="token key atrule">destination</span><span class="token punctuation">:</span> consumer<span class="token punctuation">-</span>topic
<span class="token comment"># 消费者服务</span>
<span class="token key atrule">spring</span><span class="token punctuation">:</span>
  <span class="token key atrule">cloud</span><span class="token punctuation">:</span>
    <span class="token key atrule">stream</span><span class="token punctuation">:</span>
      <span class="token key atrule">bindings</span><span class="token punctuation">:</span>
        <span class="token key atrule">demoConsumer-in-0</span><span class="token punctuation">:</span>
          <span class="token key atrule">destination</span><span class="token punctuation">:</span> consumer<span class="token punctuation">-</span>topic
          <span class="token key atrule">group</span><span class="token punctuation">:</span> consumer<span class="token punctuation">-</span>queue
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当然你依然可以不配置输出绑定，直接向输入绑定发送消息，只是这样子，你将会在 IDEA 控制台看到一条警告日志：</p><figure><img src="`+k+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>这是 Stream 源码里打印的日志，意思就是说不推荐直接向输入绑定发送消息，因为这绕过了 Binder 的某些功能和机制，可能会引发一些问题或限制。这些问题可能包括：</p><ul><li><strong>缺乏一致性配置管理</strong>：Binder 提供了集中化的配置管理，允许通过配置文件统一管理消息通道的配置。绕过 Binder 意味着开发者需要手动管理这些配置，可能导致配置不一致的问题；</li><li><strong>失去某些特性</strong>：绑定器提供了很多高级特性，如消息转换、错误处理、重试机制等。绕过绑定器意味着可能无法利用这些特性，必须自己实现类似的功能；</li><li><strong>可维护性和可读性降低</strong>：使用 Binder 可以让代码结构更加清晰和一致，方便维护和阅读，绕过 Binder 可能会让代码变得更加复杂和难以理解。</li></ul>',11),B=n("a",{href:"#routing-key-config"},"交换机路由键配置",-1),q=t(`<p>还有一种 <strong>动态目的地</strong> 方式，那就是在省去生产者的输出绑定配置后，使用 StreamBridge 发送消息时不指定绑定名称，而是直接指定 <code>destination</code>，如：<code>streamBridge.send(&quot;consumer-topic&quot;, msg);</code>，它的本质是在没有检测对应的绑定名称时，会根据指定的 <code>destination</code> 动态创建输入/输出绑定，而由于消费者服务已经有该 <code>destination</code> 的输入绑定，那么发送至该 <code>destination</code> 的消息自然就会被消费者消费了。</p><h3 id="通道拦截器" tabindex="-1"><a class="header-anchor" href="#通道拦截器" aria-hidden="true">#</a> 通道拦截器</h3><ul><li><strong>MessageChannel</strong>：StreamBridge 内部本质是使用了 MessageChannel 进行输出绑定的建立和消息的发送，MessageChannel 接口定义消息的发送，它的子类实现则扩展了它的功能，包括拦截器等</li><li><strong>@GlobalChannelInterceptor</strong>：该注解为 StreamBridge 注入了拦截器，其属性 <code>patterns</code> 定义了哪些绑定通道在发送消息时会被拦截，默认 <code>*</code> 匹配全部，可实现前置、后置拦截</li></ul><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@Component</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CustomChannelInterceptor</span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@Bean</span>
    <span class="token annotation punctuation">@GlobalChannelInterceptor</span><span class="token punctuation">(</span>patterns <span class="token operator">=</span> <span class="token string">&quot;foo-*&quot;</span><span class="token punctuation">)</span>  <span class="token comment">// 表示 foo- 开头的绑定在发送消息时会被拦截</span>
    <span class="token keyword">public</span> <span class="token class-name">ChannelInterceptor</span> <span class="token function">consumerChannelInterceptor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ChannelInterceptor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            
            <span class="token annotation punctuation">@Override</span>
            <span class="token keyword">public</span> <span class="token class-name">Message</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> <span class="token function">preSend</span><span class="token punctuation">(</span><span class="token class-name">Message</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> message<span class="token punctuation">,</span> <span class="token class-name">MessageChannel</span> channel<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;消息发送前输出内容：&quot;</span> <span class="token operator">+</span> message<span class="token punctuation">.</span><span class="token function">getPayload</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token comment">// 如果返回 null 则不会真正发送消息</span>
                <span class="token keyword">return</span> message<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>

            <span class="token annotation punctuation">@Override</span>
            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">afterSendCompletion</span><span class="token punctuation">(</span><span class="token class-name">Message</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> msg<span class="token punctuation">,</span> <span class="token class-name">MessageChannel</span> channel<span class="token punctuation">,</span> <span class="token keyword">boolean</span> sent<span class="token punctuation">,</span> <span class="token class-name">Exception</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;消息发送后输出内容：&quot;</span> <span class="token operator">+</span> msg<span class="token punctuation">.</span><span class="token function">getPayload</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="dependencies" tabindex="-1"><a class="header-anchor" href="#dependencies" aria-hidden="true">#</a> 三种函数基础示例</h3><div class="language-xml line-numbers-mode" data-ext="xml"><pre class="language-xml"><code><span class="token comment">&lt;!-- Maven 依赖，由 Spring Cloud 官方提供，按需导入即可 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-cloud-starter-stream-rabbit<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-cloud-starter-stream-kafka<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-yaml line-numbers-mode" data-ext="yml"><pre class="language-yaml"><code><span class="token key atrule">spring</span><span class="token punctuation">:</span>
  <span class="token key atrule">cloud</span><span class="token punctuation">:</span>
    <span class="token key atrule">stream</span><span class="token punctuation">:</span>
      <span class="token key atrule">bindings</span><span class="token punctuation">:</span>
        <span class="token key atrule">demoConsumer-in-0</span><span class="token punctuation">:</span>
          <span class="token key atrule">destination</span><span class="token punctuation">:</span> consumer<span class="token punctuation">-</span>topic
          <span class="token key atrule">group</span><span class="token punctuation">:</span> consumer<span class="token punctuation">-</span>queue <span class="token comment"># 此项在 RabbitMQ 表示队列，Kafka 表示消费者组</span>
        <span class="token comment"># 表示 supplier 生产消息会发往目的 consumer-topic，也就是交由上面的消费者处理</span>
        <span class="token key atrule">demoSupplier-out-0</span><span class="token punctuation">:</span>
          <span class="token key atrule">destination</span><span class="token punctuation">:</span> consumer<span class="token punctuation">-</span>topic
        <span class="token comment"># function 类型需要配置输入、输出绑定，表示向 function-topic 发送消息后经过函数处理会再发送给 consumer-topic</span>
        <span class="token key atrule">demoFunction-in-0</span><span class="token punctuation">:</span>
          <span class="token key atrule">destination</span><span class="token punctuation">:</span> function<span class="token punctuation">-</span>topic
          <span class="token key atrule">group</span><span class="token punctuation">:</span> function<span class="token punctuation">-</span>queue <span class="token comment"># 指定交换机绑定的队列</span>
        <span class="token key atrule">demoFunction-out-0</span><span class="token punctuation">:</span>
          <span class="token key atrule">destination</span><span class="token punctuation">:</span> consumer<span class="token punctuation">-</span>topic
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@Component</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MQHandler</span> <span class="token punctuation">{</span>
    
    <span class="token comment">// 消费消息</span>
    <span class="token annotation punctuation">@Bean</span>
    <span class="token keyword">public</span> <span class="token class-name">Consumer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Message</span><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> <span class="token function">demoConsumer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> msg <span class="token operator">-&gt;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;消息消费：&quot;</span> <span class="token operator">+</span> msg<span class="token punctuation">.</span><span class="token function">getPayload</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    <span class="token comment">// 生产消息</span>
    <span class="token annotation punctuation">@Bean</span>
    <span class="token keyword">public</span> <span class="token class-name">Supplier</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Message</span><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> <span class="token function">demoSupplier</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">MessageBuilder</span><span class="token punctuation">.</span><span class="token function">withPayload</span><span class="token punctuation">(</span><span class="token string">&quot;Hello, Spring Cloud Stream!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    <span class="token comment">// 消费并生产消息，此处作用式将输入的字符串消息转为大写再输出</span>
    <span class="token annotation punctuation">@Bean</span>
    <span class="token keyword">public</span> <span class="token class-name">Function</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Message</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span><span class="token punctuation">,</span> <span class="token class-name">Message</span><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> <span class="token function">demoFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token class-name">String</span><span class="token operator">::</span><span class="token function">toUpperCase</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
<span class="token punctuation">}</span>

<span class="token annotation punctuation">@RestController</span>
<span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">&quot;/demo&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DemoController</span> <span class="token punctuation">{</span>
    
    <span class="token annotation punctuation">@Resource</span>
    <span class="token keyword">private</span> <span class="token class-name">StreamBridge</span> streamBridge<span class="token punctuation">;</span>
    
    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">&quot;/test&quot;</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 构建消息</span>
        <span class="token class-name">Message</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> msg <span class="token operator">=</span> <span class="token class-name">MessageBuilder</span><span class="token punctuation">.</span><span class="token function">withPayload</span><span class="token punctuation">(</span><span class="token string">&quot;Hello World!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 向指定的输入绑定发送消息</span>
        streamBridge<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token string">&quot;demoConsumer-in-0&quot;</span><span class="token punctuation">,</span> msg<span class="token punctuation">,</span> <span class="token class-name">MimeType</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token string">&quot;application/json&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        streamBridge<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token string">&quot;demoFunction-in-0&quot;</span><span class="token punctuation">,</span> msg<span class="token punctuation">,</span> <span class="token class-name">MimeType</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token string">&quot;application/json&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>按照上方配置和代码，当启动服务后（为方便演示，上方代码皆在同一服务），无论使用的是 RabbitMQ 还是 Kakfa，Stream 都会映射 <code>destination</code>、<code>group</code> 到对应 MQ 系统中的概念，比如在 RabbitMQ 就分别代表着 <code>Exchange</code>、<code>Queue</code>，在 Kafka 中则是 <code>Topic</code>、<code>ConsumerGroup</code>。</p><p>至于为什么没有配置 MQ 服务环境地址，是因为 Stream 依赖包含了 RabbitMQ、Kafka 在 Spring Boot 中的集成，所以缺省环境配置时，会使用 Spring Boot 自带的默认值去连接 Broker。当然想指定环境的话，就如同 Spring Boot 集成 MQ 时所做的配置一样。</p><div class="language-yaml line-numbers-mode" data-ext="yml"><pre class="language-yaml"><code><span class="token key atrule">spring</span><span class="token punctuation">:</span>
  <span class="token key atrule">kafka</span><span class="token punctuation">:</span>
   <span class="token key atrule">bootstrap-servers</span><span class="token punctuation">:</span> localhost<span class="token punctuation">:</span><span class="token number">9092</span>
  <span class="token key atrule">rabbitmq</span><span class="token punctuation">:</span>
    <span class="token comment"># 确认机制需要依靠 Spring AMQP 实现，Stream 并不提供，Binder 本身使用的也是 Spring Boot 的 Connection Factory，</span>
    <span class="token comment"># Stream 支持 Spring AMQP 的所有配置</span>
    <span class="token key atrule">publisher-returns</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>
    <span class="token key atrule">publisher-confirm-type</span><span class="token punctuation">:</span> simple
    <span class="token key atrule">host</span><span class="token punctuation">:</span> localhost
    <span class="token key atrule">username</span><span class="token punctuation">:</span> admin
    <span class="token key atrule">password</span><span class="token punctuation">:</span> admin123
    <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">5672</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="其它重要配置" tabindex="-1"><a class="header-anchor" href="#其它重要配置" aria-hidden="true">#</a> 其它重要配置</h2><p><strong>PS</strong>：以下所有配置以 RabbitMQ 为例，Kafka 也是类似，不清楚的配置只需要看官文即可，很详细。</p><h3 id="指定注册的消息处理器" tabindex="-1"><a class="header-anchor" href="#指定注册的消息处理器" aria-hidden="true">#</a> 指定注册的消息处理器</h3><p>上面提到 Stream 启动会检测 <code>Function</code>、<code>Supplier</code>、<code>Consumer</code> 三种类型函数 Bean 作为消息处理器，但在实际中也并非所有的函数式 Bean 都是用于 Stream 的消息处理，因此可以用以下配置指定需要注册的函数 Bean 的名称：</p><div class="language-yaml line-numbers-mode" data-ext="yml"><pre class="language-yaml"><code><span class="token key atrule">spring</span><span class="token punctuation">:</span>
  <span class="token key atrule">cloud</span><span class="token punctuation">:</span>
    <span class="token key atrule">function</span><span class="token punctuation">:</span>
      <span class="token key atrule">definition</span><span class="token punctuation">:</span> demoConsumer;demoSupplier;demoFunction
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用分号进行分割，注意不要出现空格或其它符号，因为该字符串属性分割的源码是调用的 <code>String.split(&quot;;&quot;)</code>，会将其它符号也当作 Bean 名称的一部分。<strong>注意</strong>：当存在多个相同类型的函数 Bean 时，比如有两个 <code>Consumer</code> Bean，也必须指定该配置，因为 Stream 默认是依赖应用上下文来确定哪个是消费者，并不会依赖绑定名称确定。</p><p>除此之外还可用管道符（<code>|</code>）连接多个函数：</p><div class="language-yaml line-numbers-mode" data-ext="yml"><pre class="language-yaml"><code><span class="token key atrule">spring</span><span class="token punctuation">:</span>
  <span class="token key atrule">cloud</span><span class="token punctuation">:</span>
    <span class="token key atrule">function</span><span class="token punctuation">:</span>
      <span class="token key atrule">definition</span><span class="token punctuation">:</span> demoFunctionOne<span class="token punctuation">|</span>demoFunctionTwo
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>demoFunctionOne|demoFunctionTwo</code> 的意思是连接两个 <code>Function</code> 函数（假设已声明）组合成一个新的函数，并且 <code>demoFunctionOne</code> 生产的消息将直接作为 <code>demoFunctionTwo</code> 的输入，而在指定该组合函数的输入/输出绑定时，也应该使用这个组合名称，如 <code>demoFunctionOne|demoFunctionTwo-in-0</code>、<code>demoFunctionOne|demoFunctionTwo-out-0</code>。显然这很冗长，Stream 也考虑到这点，并提供了为绑定声明别名的方式：</p><div class="language-yaml line-numbers-mode" data-ext="yml"><pre class="language-yaml"><code><span class="token key atrule">spring</span><span class="token punctuation">:</span>
  <span class="token key atrule">cloud</span><span class="token punctuation">:</span>
    <span class="token key atrule">function</span><span class="token punctuation">:</span>
      <span class="token key atrule">definition</span><span class="token punctuation">:</span> demoFunctionOne<span class="token punctuation">|</span>demoFunctionTwo
    <span class="token key atrule">stream</span><span class="token punctuation">:</span>
      <span class="token key atrule">function</span><span class="token punctuation">:</span>
        <span class="token key atrule">bindings</span><span class="token punctuation">:</span> 
          <span class="token comment"># 属性指定输入/输出绑定名称，值则为别名</span>
          <span class="token key atrule">demoFunctionOne|demoFunctionTwo-in-0</span><span class="token punctuation">:</span> FunctionCompositionIn
          <span class="token key atrule">demoFunctionOne|demoFunctionTwo-out-0</span><span class="token punctuation">:</span> FunctionCompositionOut
      <span class="token key atrule">bindings</span><span class="token punctuation">:</span>
        <span class="token comment"># 直接使用别名</span>
        <span class="token key atrule">FunctionCompositionIn</span><span class="token punctuation">:</span>
          <span class="token key atrule">destination</span><span class="token punctuation">:</span> sf<span class="token punctuation">-</span>exchange
          <span class="token key atrule">group</span><span class="token punctuation">:</span> sf<span class="token punctuation">-</span>queue
        <span class="token key atrule">FunctionCompositionOut</span><span class="token punctuation">:</span>
          <span class="token key atrule">destination</span><span class="token punctuation">:</span> consumer<span class="token punctuation">-</span>exchange 
        
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="supplier-轮询配置" tabindex="-1"><a class="header-anchor" href="#supplier-轮询配置" aria-hidden="true">#</a> Supplier 轮询配置</h3><p>Supplier 默认是 1s 执行一次生产消息，既然是默认，那么就肯定有动态配置方式，如下：</p><div class="language-yaml line-numbers-mode" data-ext="yml"><pre class="language-yaml"><code><span class="token key atrule">spring</span><span class="token punctuation">:</span>
  <span class="token comment"># Supplier 全局消息发送轮询配置</span>
  <span class="token key atrule">integration</span><span class="token punctuation">:</span>
    <span class="token key atrule">poller</span><span class="token punctuation">:</span>
      <span class="token key atrule">cron</span><span class="token punctuation">:</span> 1 * * * * <span class="token punctuation">?</span>          <span class="token comment"># CRON 表达式</span>
      <span class="token key atrule">fixed-delay</span><span class="token punctuation">:</span> 5s            <span class="token comment"># 固定延迟，与 fixed-rate、cron 互斥</span>
      <span class="token key atrule">fixed-rate</span><span class="token punctuation">:</span> 2s             <span class="token comment"># 固定频率，与 fixed-delay、cron 互斥</span>
      <span class="token key atrule">initial-delay</span><span class="token punctuation">:</span> <span class="token number">5</span>           <span class="token comment"># 初始延迟，应用于 fixed-delay、fixed-rate，对 cron 无效</span>
      <span class="token key atrule">max-messages-per-poll</span><span class="token punctuation">:</span> <span class="token number">2</span>   <span class="token comment"># 每次轮询的最大消息条数</span>
      <span class="token key atrule">receive-timeout</span><span class="token punctuation">:</span> 5s        <span class="token comment"># 接收超时时间</span>
  <span class="token key atrule">could</span><span class="token punctuation">:</span>
    <span class="token key atrule">function</span><span class="token punctuation">:</span>
      <span class="token key atrule">definition</span><span class="token punctuation">:</span> demoSupplier
	<span class="token key atrule">stream</span><span class="token punctuation">:</span>
	  <span class="token key atrule">bindings</span><span class="token punctuation">:</span>
	    <span class="token key atrule">demoSupplier-out-0</span><span class="token punctuation">:</span>
	      <span class="token key atrule">destination</span><span class="token punctuation">:</span> consumer<span class="token punctuation">-</span>exchange
	      <span class="token comment"># 指定当前绑定的生产者配置</span>
	      <span class="token key atrule">producer</span><span class="token punctuation">:</span>
	        <span class="token comment"># 预先创建的队列，Stream 关于队列默认是消费者服务启动时才创建，即只有生产者存在时并不会创建队列并绑定交换机</span>
            <span class="token comment"># 若不配置此项，那么当消费者服务未启动时，发送到此绑定的所有消息将丢失（也就是只有交换机，而没有绑定队列）</span>
            <span class="token key atrule">required-groups</span><span class="token punctuation">:</span>
              <span class="token punctuation">-</span> prepare<span class="token punctuation">-</span>queue
            <span class="token comment"># 只针对当前 Supplier 输出绑定的轮询配置</span>
	        <span class="token key atrule">poller</span><span class="token punctuation">:</span>
              <span class="token key atrule">fixed-delay</span><span class="token punctuation">:</span> 1m             <span class="token comment"># 发送间隔，默认 1s</span>
              <span class="token key atrule">initial-delay</span><span class="token punctuation">:</span> 1s           <span class="token comment"># 初始发送延迟时间，默认 0s，其下 units 属性可控制时间单位</span>
              <span class="token key atrule">max-messages-per-poll</span><span class="token punctuation">:</span> <span class="token number">1</span>    <span class="token comment"># 每次轮询发送的消息条数，默认 1 条</span>
              <span class="token key atrule">cron</span><span class="token punctuation">:</span> 0/1 * * * * <span class="token punctuation">?</span>         <span class="token comment"># CRON 表达式指定发送周期，比 fixed-delay 优先级更高</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="routing-key-config" tabindex="-1"><a class="header-anchor" href="#routing-key-config" aria-hidden="true">#</a> 交换机类型、路由键配置</h3><p>Stream 根据绑定信息所创建的交换机默认都为 <code>Topic</code>，且路由键匹配规则为 <code>#</code>，也就是匹配全部，若想指定自己的路由键（一个交换机绑定多个队列时），则按如下方式：</p><div class="language-yaml line-numbers-mode" data-ext="yml"><pre class="language-yaml"><code><span class="token comment"># 生产者配置</span>
<span class="token key atrule">spring</span><span class="token punctuation">:</span>
  <span class="token key atrule">could</span><span class="token punctuation">:</span>
    <span class="token key atrule">stream</span><span class="token punctuation">:</span>
	  <span class="token key atrule">bindings</span><span class="token punctuation">:</span>
        <span class="token key atrule">demoConsumer-out-0</span><span class="token punctuation">:</span>
          <span class="token key atrule">destination</span><span class="token punctuation">:</span> consumer<span class="token punctuation">-</span>exchange
      <span class="token key atrule">rabbit</span><span class="token punctuation">:</span>
        <span class="token key atrule">bindings</span><span class="token punctuation">:</span>
          <span class="token key atrule">demoConsumer-out-0</span><span class="token punctuation">:</span>
            <span class="token key atrule">producer</span><span class="token punctuation">:</span>
              <span class="token comment"># 指定固定的路由键，routing-key 在 3.2.x 版本不可用，只是提前暴露了属性配置而已</span>
              <span class="token comment"># 4.x 才可用，还是优先推荐用 routing-key-expression，两者互斥</span>
              <span class="token key atrule">routing-key</span><span class="token punctuation">:</span> string<span class="token punctuation">-</span>consumer<span class="token punctuation">-</span>key
              <span class="token comment"># 指定路由键表达式 SpEL，这里的意思是 Message 的 Headers 属性 type 表示路由键</span>
              <span class="token comment"># 通过此来实现动态路由，常用于一个交换机有多个队列且路由键不同时</span>
              <span class="token comment"># 默认为 {destination}，也就是取交换机的名称作为路由键</span>
              <span class="token key atrule">routing-key-expression</span><span class="token punctuation">:</span> headers.type

<span class="token comment"># 消费者配置</span>
<span class="token key atrule">spring</span><span class="token punctuation">:</span>
  <span class="token key atrule">could</span><span class="token punctuation">:</span>
    <span class="token key atrule">function</span><span class="token punctuation">:</span>
      <span class="token key atrule">definition</span><span class="token punctuation">:</span> demoConsumer
	<span class="token key atrule">stream</span><span class="token punctuation">:</span>
	  <span class="token key atrule">bindings</span><span class="token punctuation">:</span>
	    <span class="token comment"># 放在消费者服务里的配置</span>
	    <span class="token key atrule">demoConsumer-in-0</span><span class="token punctuation">:</span>
          <span class="token key atrule">destination</span><span class="token punctuation">:</span> consumer<span class="token punctuation">-</span>exchange
          <span class="token key atrule">group</span><span class="token punctuation">:</span> consumer<span class="token punctuation">-</span>queue             <span class="token comment"># 指定交换机绑定队列的名称</span>
          <span class="token comment"># producer: 生产者配置 </span>
          <span class="token comment"># consumer: 消费者配置</span>
      <span class="token comment"># 在这里配置的是 RabbitMQ Binder 针对 RabbitMQ 生产者/消费者的属性</span>
      <span class="token comment"># 跟在绑定中的 producer/consumer 的配置是有些重叠的，可理解为后者是 Stream 提供的对所有 Binder 的生产与消费的适配配置</span>
      <span class="token key atrule">rabbit</span><span class="token punctuation">:</span>
        <span class="token key atrule">bindings</span><span class="token punctuation">:</span>
          <span class="token comment"># 放在消费者服务里的配置</span>
          <span class="token key atrule">demoConsumer-in-0</span><span class="token punctuation">:</span> <span class="token comment"># 注意名称要跟 bindings 中的一致</span>
            <span class="token key atrule">consumer</span><span class="token punctuation">:</span>
              <span class="token comment"># 设置交换机类型，默认 topic，可填 direct、fanout、headers</span>
              <span class="token key atrule">exchange-type</span><span class="token punctuation">:</span> direct
              <span class="token comment"># 队列绑定交换机的路由键</span>
              <span class="token key atrule">binding-routing-key</span><span class="token punctuation">:</span> string<span class="token punctuation">-</span>consumer<span class="token punctuation">-</span>key<span class="token punctuation">,</span>string<span class="token punctuation">-</span>consumer<span class="token punctuation">-</span>key<span class="token punctuation">-</span>two
              <span class="token comment"># binding-routing-key 指定了多个路由键时的分隔符，默认 null</span>
              <span class="token key atrule">binding-routing-key-delimiter</span><span class="token punctuation">:</span> <span class="token string">&quot;,&quot;</span>
              <span class="token comment"># 绑定未指定 group 时创建的匿名队列前缀，默认 anonymous，即 {destination}.anonymous.{base64 of UUID}</span>
              <span class="token key atrule">anonymous-group-prefix</span><span class="token punctuation">:</span> ephemeral
              <span class="token comment"># 只用 group 作为队列名，默认 {destination}.{group}</span>
              <span class="token key atrule">queue-name-group-only</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果使用 <code>routing-key</code> 属性，那么通过 <code>StreamBridge </code> 发送消息后会自动根据路由键寻找绑定的队列，而使用 <code>routing-key-expression</code> 的话，则要配合指定的 SpEL 表达式进行操作，比如上方指定 <code>headers.type</code>，那么就需要在消息 Header 中指定 <code>type</code> 属性以确定路由键。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@RestController</span>
<span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">&quot;demo&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DemoController</span> <span class="token punctuation">{</span>
    
    <span class="token annotation punctuation">@Resource</span>
    <span class="token keyword">private</span> <span class="token class-name">StreamBridge</span> streamBridge<span class="token punctuation">;</span>
    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">&quot;/send&quot;</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">send</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Message</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> msg <span class="token operator">=</span> <span class="token class-name">MessageBuilder</span><span class="token punctuation">.</span><span class="token function">withPayload</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span>
                <span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">&quot;type&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;string-consumer-key&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 记得是向输出绑定发送消息哦，直接向输入绑定发送消息是不会携带路由键的</span>
        streamBridge<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token string">&quot;demoConsumer-out-0&quot;</span><span class="token punctuation">,</span> msg<span class="token punctuation">,</span> <span class="token class-name">MimeType</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token string">&quot;application/json&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="消费者多线程并发消费" tabindex="-1"><a class="header-anchor" href="#消费者多线程并发消费" aria-hidden="true">#</a> 消费者多线程并发消费</h3><div class="language-properties line-numbers-mode" data-ext="properties"><pre class="language-properties"><code><span class="token comment"># 消息消费的并发线程数，默认 1，交换机类型为 direct 时不可用，线程名称：{group}-{1..count}</span>
<span class="token key attr-name">spring.cloud.stream.bindings.{function-name}.consumer.concurrency</span><span class="token punctuation">:</span> <span class="token value attr-value">2</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>在执行函数中可以通过打印线程名称看到效果。</p><h2 id="小结" tabindex="-1"><a class="header-anchor" href="#小结" aria-hidden="true">#</a> 小结</h2><p>Spring Cloud Stream 系列的第一篇就到此结束，先理解 Stream 的概念和基础使用方式，后续的文章再继续讲解关于死信、延迟、多 Binder 等的配置与使用。</p>`,34);function C(w,_){const e=p("ExternalLinkIcon"),o=p("RouterLink");return i(),l("div",null,[n("blockquote",null,[n("p",null,[n("strong",null,[n("a",v,[s("Spring Cloud Stream"),a(e)])]),s("：是用于构建与共享消息传递系统连接的高度可扩展的事件驱动微服务，其提供一个灵活的编程模型，基于 Spring 习语来实现对各类常见的 MQ 系统的支持，如官方自己提供的 RabbitMQ Binder、Kafka Binder，还有其它 MQ 厂商自己提供的适配。其内部使用 Spring Integration 提供与 broker 的连接，并能够在同样的配置、代码下实现不同 MQ 产品的消息发布订阅、消费者组、持久化、分区等特性。")])]),g,n("ul",null,[b,n("li",null,[y,s("：表示消息的生产，只针对消息的输出，该类型作为数据的源，对数据只生产不消费，它的执行可分为命令式或被动式 "),n("ul",null,[n("li",null,[s("命令式：Stream 提供了轮询机制，默认每隔 1s 执行函数，即每一秒发送一条消息到绑定的输出目标，配置参数"),n("a",h,[s("在这"),a(e)])]),n("li",null,[s("响应式：查看"),n("a",f,[s("官文"),a(e)]),s("，其实就是利用响应式编程风格（Project Reactor）来实现消息的生成，而不依赖轮询机制")])])]),S]),x,n("p",null,[s("简单说，就是输入、输出绑定都会有各自的配置，而直接向输入绑定发送消息，那么输出绑定的配置就不会被检测执行，这一点在本篇下面提到的"),B,s("后发送消息会有体现，而在"),a(o,{to:"/posts/framework/spring/spring_cloud_stream_two.html"},{default:u(()=>[s("第二篇")]),_:1}),s("介绍的死信、延迟队列消息发送与消费也是如此。")]),q])}const j=c(m,[["render",C],["__file","spring_cloud_stream_one.html.vue"]]);export{j as default};
