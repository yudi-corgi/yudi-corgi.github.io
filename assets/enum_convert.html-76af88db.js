const e=JSON.parse('{"key":"v-09312a04","path":"/posts/dev_experience/enum_convert.html","title":"枚举字典的巧用","lang":"zh-CN","frontmatter":{"lang":"zh-CN","title":"枚举字典的巧用","description":"介绍基于 MP 的枚举字典转化和封装抽象","tag":["开发技巧"],"date":"2023-09-26T00:00:00.000Z","sticky":true,"category":"开发技巧","cover":"/assets/images/stuart_cover1.jpg","icon":"material-symbols:dictionary-outline","isOriginal":true,"head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/black-hole/posts/dev_experience/enum_convert.html"}],["meta",{"property":"og:site_name","content":"Black Hole"}],["meta",{"property":"og:title","content":"枚举字典的巧用"}],["meta",{"property":"og:description","content":"介绍基于 MP 的枚举字典转化和封装抽象"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://mister-hope.github.io/black-hole/assets/images/stuart_cover1.jpg"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-10-29T14:13:39.000Z"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["meta",{"name":"twitter:image:alt","content":"枚举字典的巧用"}],["meta",{"property":"article:author","content":"YUDI-Corgi"}],["meta",{"property":"article:tag","content":"开发技巧"}],["meta",{"property":"article:published_time","content":"2023-09-26T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-10-29T14:13:39.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"枚举字典的巧用\\",\\"image\\":[\\"https://mister-hope.github.io/black-hole/\\"],\\"datePublished\\":\\"2023-09-26T00:00:00.000Z\\",\\"dateModified\\":\\"2024-10-29T14:13:39.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"YUDI-Corgi\\",\\"url\\":\\"https://github.com/yudi-corgi\\"}]}"]]},"headers":[{"level":2,"title":"序","slug":"序","link":"#序","children":[]},{"level":2,"title":"基于 MyBatisPlus + Jackson 实现枚举出入参转换","slug":"基于-mybatisplus-jackson-实现枚举出入参转换","link":"#基于-mybatisplus-jackson-实现枚举出入参转换","children":[]},{"level":2,"title":"其它","slug":"其它","link":"#其它","children":[]}],"git":{"createdTime":1705063901000,"updatedTime":1730211219000,"contributors":[{"name":"YUDI-Corgi","email":"1019509861@qq.com","commits":4}]},"readingTime":{"minutes":6.91,"words":2073},"filePathRelative":"posts/dev_experience/enum_convert.md","localizedDate":"2023年9月26日","excerpt":"<h2> 序</h2>\\n<p>一般在项目当中，关于字典的管理方式可概括为以下两种：</p>\\n<ol>\\n<li>交由数据库维护，前后端需要时调用接口获取，好处是可以对字典做成页面配置，随时增删查改，前后端同步；</li>\\n<li>前后端根据业务约定好字典内容后，各自存储，这样就无需依赖 API 调用。</li>\\n</ol>\\n<p>第一种做法比较有利于字典需要频繁变化的场景，缺点是需要网络调用接口；而第二种虽然避免了网络问题，但要求前后端手动同步好字典数据，以免出错，对于变化较多的字典较为麻烦。</p>\\n<p>用哪一种根据业务决定即可，因为根据实际情况，前端总是需要对字典数据做一些特殊处理，比如根据订单状态执行不同操作，需要依赖字典做条件判断，这避免不了需要在前端存储一份字典数据的问题。（个人）目前所接触过的实际项目也基本都是前后端自己维护，除了个别纯后台管理系统才采用了第一种方案。</p>"}');export{e as data};
