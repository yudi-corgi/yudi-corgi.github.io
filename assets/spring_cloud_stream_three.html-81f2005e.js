import{_ as c}from"./plugin-vue_export-helper-c27b6911.js";import{r as e,o as i,c as l,a as n,b as s,d as a,w as u,e as p}from"./app-24a8d5b3.js";const r="/assets/分区结构图-74c2846d.png",d="/assets/stream3-IDEA控制台信息-d752ee48.jpg",k="/assets/GUI交换机信息-d445da2f.png",m="/assets/stream3-IDEA控制台信息2-43cdaac3.png",v={},g=p('<h2 id="分区" tabindex="-1"><a class="header-anchor" href="#分区" aria-hidden="true">#</a> 分区</h2><p>Spring Cloud Stream 提供对给定应用程序的多个实例之间的数据分区的支持。在分区场景中，物理通信介质（例如 Broker 的 Topic）被视为由多个分区组成。一个或多个生产者应用程序实例将数据发送到多个消费者应用程序实例，并确保以共同特征标识的数据由同一消费者实例处理。</p><p>Spring Cloud Stream 提供了一个通用抽象，用于以统一的方式实现分区处理用例。因此，无论 MQ 本身是否自然分区（如 Kafka）或不自然分区（如 RabbitMQ），都可以使用分区。</p><figure><img src="'+r+`" alt="分区结构图" tabindex="0" loading="lazy"><figcaption>分区结构图</figcaption></figure><h3 id="分区配置" tabindex="-1"><a class="header-anchor" href="#分区配置" aria-hidden="true">#</a> 分区配置</h3><p>对于分区的使用，在生产者和消费者之间都需要进行配置，属性不多就几个：</p><div class="language-yaml line-numbers-mode" data-ext="yml"><pre class="language-yaml"><code><span class="token key atrule">spring</span><span class="token punctuation">:</span>
  <span class="token key atrule">cloud</span><span class="token punctuation">:</span>
    <span class="token key atrule">stream</span><span class="token punctuation">:</span>
      <span class="token comment"># 表示分区数量与当前实例的索取索引，在这里配置跟在下面的消费者中配置是一样的效果</span>
      <span class="token comment"># 只不过这是全局配置，而下面是只针对绑定，比如两个绑定有不同的分区配置</span>
      <span class="token comment"># instance-count: 2</span>
      <span class="token comment"># instance-index: 0</span>
      <span class="token key atrule">bindings</span><span class="token punctuation">:</span>
        <span class="token key atrule">partitionedConsumer-in-0</span><span class="token punctuation">:</span>
          <span class="token key atrule">destination</span><span class="token punctuation">:</span> partitioned<span class="token punctuation">-</span>exchange
          <span class="token key atrule">group</span><span class="token punctuation">:</span> partitioned<span class="token punctuation">-</span>consumer<span class="token punctuation">-</span>queue
          <span class="token key atrule">consumer</span><span class="token punctuation">:</span>
            <span class="token comment"># 是否从分区生产者获取消息，使用该属性表示消费者开启分区功能</span>
            <span class="token key atrule">partitioned</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>
            <span class="token comment"># 指定应用实例部署的数量</span>
            <span class="token comment"># 创建的队列也会有两个，默认名称：{destination}.{group}-{index}，默认路由键：{partitioned}-{index}</span>
            <span class="token key atrule">instance-count</span><span class="token punctuation">:</span> <span class="token number">2</span>
            <span class="token comment"># 该属性指示当前实例的索引（也叫分区 ID），生产者发送消息时计算所得的分区索引与此相同，则消息会被此实例的消费者消费</span>
            <span class="token key atrule">instance-index</span><span class="token punctuation">:</span> <span class="token number">0</span>
        <span class="token key atrule">partitionedConsumer-out-0</span><span class="token punctuation">:</span>
          <span class="token key atrule">destination</span><span class="token punctuation">:</span> partitioned<span class="token punctuation">-</span>exchange
          <span class="token key atrule">producer</span><span class="token punctuation">:</span>
            <span class="token comment"># 分区数量，生产者是否开启分区是根据 partition-key-expression 或 partition-key-extractor-name 是否有值确定</span>
            <span class="token key atrule">partition-count</span><span class="token punctuation">:</span> <span class="token number">2</span>
            <span class="token comment"># 分区键，通过该 Key 决定路由的分区，分区计算方式默认是：{SpEL 计算结果 % partition-count}</span>
            <span class="token key atrule">partition-key-expression</span><span class="token punctuation">:</span> headers
            <span class="token comment"># 分区 ID 选择 SpEL，与分区键搭配使用</span>
            <span class="token key atrule">partition-selector-expression</span><span class="token punctuation">:</span> index
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>重点讲述下 <code>partition-key-expression</code> 和 <code>partition-selector-expression</code> 两个配置：</p><ul><li>单独使用 <code>partition-key-expression</code> 时，该属性表达式解析的结果就直接充当了分区键，分区索引的计算是直接取分区键的哈希值取模分区数量得到；</li><li>两个都使用时，<code>partition-selector-expression</code> 属性的 SpEL 表达式在解析时会取 <code>partition-key-expression</code> 的 SpEL 表达式解析结果作为<strong>根对象</strong>，简单说就是前者会在后者的解析结果上再进一步解析，这里涉及到 SpEL 表达式是如何解析的原理，说起来繁琐，也不在本篇内容范围，网上有诸多资料，感兴趣的读者可以自行查阅。最后也是拿解析结果的哈希值取模计算得到分区索引。</li></ul><p>上面的配置中关于两者配置意思是：<code>partition-key-expression</code> SpEL 表达式解析后会拿到 <code>Message#MessageHeaders</code>，而 <code>partition-selector-expression</code> 则表示从 <code>Message#MessageHeaders</code> 中拿到 <code>index</code> 属性。如果只想用 <code>partition-key-expression</code>，那么可如下指定：</p><div class="language-properties line-numbers-mode" data-ext="properties"><pre class="language-properties"><code><span class="token key attr-name">spring.cloud.stream.bindings.partitionedConsumer-out-0.producer.partition-key-expression</span><span class="token punctuation">=</span><span class="token value attr-value">headers.index</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>以上就表达了直接取消息属性中的 <code>index</code> 作为分区键去计算分区索引。</p><p>虽然两个属性搭配看起来有多余，一个 SpEL 表达式貌似就能满足分区选择的需求。但其实 <code>partition-key-expression</code> 主要用于指定分区键的计算逻辑，它可以是一个复杂的 SpEL 表达式，可以根据消息的头信息、 payload 等信息来计算分区键，而 <code>partition-selector-expression</code> 则是用于从前者计算出的结果中选择最终的分区键，这个属性通常用于简单地选择或转换分区键，而不需要复杂的计算逻辑。</p><p>比如说：在 MQ 服务中，每个消息都包含一个头信息 <code>customerType</code>，该头信息可以取值为 <code>VIP</code>、<code>NORMAL</code> 或 <code>GUEST</code>。我们想要根据 <code>customerType</code> 将消息分区到不同的队列中，但是也想要根据 <code>VIP</code> 类型的消息的 <code>priority</code> 属性来进一步分区。在这种情况下，就可以使用 <code>partition-key-expression</code> 来计算出一个对象，该对象包含 <code>customerType</code> 和 <code>priority</code> 属性，然后使用 <code>partition-selector-expression</code> 进一步选择该对象中的某个属性作为最终的分区键。</p><p>说完配置，再写上消费者代码：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@Component</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MQHandler</span> <span class="token punctuation">{</span>
	
    <span class="token comment">// 自增对象，用于测试消息路由分区</span>
    <span class="token annotation punctuation">@Bean</span>
    <span class="token keyword">public</span> <span class="token class-name">AtomicInteger</span> <span class="token function">index</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    <span class="token annotation punctuation">@Bean</span>
    <span class="token keyword">public</span> <span class="token class-name">Consumer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Message</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> <span class="token function">partitionedConsumer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> msg <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
            <span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> msg<span class="token punctuation">.</span><span class="token function">getHeaders</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">&quot;selector&quot;</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">2</span><span class="token punctuation">;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;消息分区索引：&quot;</span> <span class="token operator">+</span> index <span class="token operator">+</span> <span class="token string">&quot;，内容：&quot;</span> <span class="token operator">+</span> msg<span class="token punctuation">.</span><span class="token function">getPayload</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>

<span class="token annotation punctuation">@RestController</span>
<span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">&quot;/send&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SendController</span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@Resource</span>
    <span class="token keyword">private</span> <span class="token class-name">AtomicInteger</span> index<span class="token punctuation">;</span>
    <span class="token annotation punctuation">@Resource</span>
    <span class="token keyword">private</span> <span class="token class-name">StreamBridge</span> streamBridge<span class="token punctuation">;</span>

    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">&quot;demo&quot;</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">demo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Message</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> msg <span class="token operator">=</span> <span class="token class-name">MessageBuilder</span><span class="token punctuation">.</span><span class="token function">withPayload</span><span class="token punctuation">(</span><span class="token string">&quot;Hello World&quot;</span><span class="token punctuation">)</span>
                <span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">&quot;index&quot;</span><span class="token punctuation">,</span> index<span class="token punctuation">.</span><span class="token function">incrementAndGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        streamBridge<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token string">&quot;partitionedConsumer-out-0&quot;</span><span class="token punctuation">,</span> msg<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>因为是要测试分区效果，所以就需要启动多个实例，还记得上面为实例配置的 <code>instance-index</code> 分区索引吗？当启动第二个实例时，记得修改它：</p><div class="language-properties line-numbers-mode" data-ext="properties"><pre class="language-properties"><code><span class="token comment"># 上面是 0，这里改为 1，分区索引从 0 开始</span>
<span class="token key attr-name">spring.cloud.stream.bindings.partitionedConsumer-in-0.consumer.instance-index</span><span class="token punctuation">=</span><span class="token value attr-value">1</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>当两个服务实例都启动后，发送消息就可以看到效果，分区索引 0 都发到第一个实例，分区索引 1 都发到第二个实例了：</p><figure><img src="`+d+'" alt="IDEA 控制台信息" tabindex="0" loading="lazy"><figcaption>IDEA 控制台信息</figcaption></figure><p>在 GUI 平台上也可以看到交换机绑定了两个队列：</p><figure><img src="'+k+`" alt="GUI 交换机信息" tabindex="0" loading="lazy"><figcaption>GUI 交换机信息</figcaption></figure><h3 id="自定义分区策略" tabindex="-1"><a class="header-anchor" href="#自定义分区策略" aria-hidden="true">#</a> 自定义分区策略</h3><p>如果不想依赖 SpEL 表达式来实现分区选择，那么也可以实现接口来自定义分区策略。</p><p>相关属性如下：</p><div class="language-properties line-numbers-mode" data-ext="properties"><pre class="language-properties"><code><span class="token comment"># 自定义分区 Key 提取策略，填写接口实现的 Bean 名称，目的跟 partition-key-expression 相同</span>
<span class="token key attr-name">spring.cloud.stream.bindings.{binding-name}.producer.partition-key-extractor-name</span><span class="token punctuation">=</span><span class="token value attr-value">customKeyExtractorStrategy</span>
<span class="token comment"># 自定义分区索引选择策略，填写接口实现的 Bean 名称</span>
<span class="token key attr-name">spring.cloud.stream.bindings.{binding-name}.producer.partition-selector-name</span><span class="token punctuation">=</span><span class="token value attr-value">customSelectorStrategy</span>
<span class="token comment"># 以上两者跟 partition-key-expression 属性互斥</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>分别对应的接口实现：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@Configuration</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StreamConfig</span> <span class="token punctuation">{</span>
    
    <span class="token doc-comment comment">/**
     * 自定义分区键提取策略
     * <span class="token keyword">@return</span> PartitionKeyExtractorStrategy
     */</span>
    <span class="token annotation punctuation">@Bean</span>
    <span class="token keyword">public</span> <span class="token class-name">PartitionKeyExtractorStrategy</span> <span class="token function">customKeyExtractorStrategy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 这里简单演示，比如提取消息 headers 属性作为分区键，使用时根据实际情况编写分区键计算逻辑即可</span>
        <span class="token keyword">return</span> message <span class="token operator">-&gt;</span> message<span class="token punctuation">.</span><span class="token function">getHeaders</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">&quot;partition-index&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token doc-comment comment">/**
     * 自定义分区索引选择策略，计算出最终的分区索引
     * <span class="token keyword">@return</span> PartitionSelectorStrategy
     */</span>
    <span class="token annotation punctuation">@Bean</span>
    <span class="token keyword">public</span> <span class="token class-name">PartitionSelectorStrategy</span> <span class="token function">customSelectorStrategy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token punctuation">(</span>key<span class="token punctuation">,</span> partitionCount<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
            <span class="token comment">// key 是分区键提取策略返回的分片键，partitionCount 自然就是分区数量了</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;分区键：&quot;</span> <span class="token operator">+</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">%</span> partitionCount<span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>两个策略的使用都比较简单，效果就不作展示，读者可自行实践。</p><h2 id="多输入-输出参数的函数" tabindex="-1"><a class="header-anchor" href="#多输入-输出参数的函数" aria-hidden="true">#</a> 多输入/输出参数的函数</h2><p>在介绍 Stream 程序的消息消费函数 <code>Consumer</code>、<code>Function</code> 时，可以看到它们都是只接收一个消息，也就是只有一个输入，并且消息生产 <code>Supplier</code>、<code>Function</code> 两者也是只有一个输出。</p><p>但从 Stream 3.0 版本开始，就支持具有多个输入或输出参数的函数，它的实现是为了应对以下类似的场景：</p><ul><li>大数据场景：需要处理的数据源无组织，并且包含各类数据元素，而开发者需要对其进行整理</li><li>数据聚合：将多个数据源的数据进行合并计算</li></ul><p>也就是说，可以使用单个函数来接受或生成多个数据流。该功能的实现依赖于 <strong>Project Reactor</strong> 提供的抽象（即 <code>Flux</code> 和 <code>Mono</code>）来封装消息，并且另一个重要的点是，Java 中虽然提供了多种抽象（数组、集合、队列等）来表示多个事物，但是这些抽象都并非能同时具有数量信息、多类型存储的特征，比如集合或者数组，只允许存储单种类型的多个元素，或者将所有元素都向上转化为 Object 类型，这就无法达到 Stream 所想要的效果，影响了其透明类型转换的功能。因此，Stream 引入了 <strong>Project Reactor</strong> 提供的另一个抽象概念 - <strong>元组（Tuple）</strong>。</p><p>元组这玩意儿想来大多数 Javaer 还是知道的，不过这里还是可以简单说下，元组就相当于以个容器，可以存储多个元素以及指定各自的类型，并且可以按照设置元素的顺序来获取数据，类源码如下：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// 这是一个存储两个元素的元组</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Tuple2</span><span class="token generics"><span class="token punctuation">&lt;</span>T1<span class="token punctuation">,</span> T2<span class="token punctuation">&gt;</span></span> <span class="token keyword">implements</span> <span class="token class-name">Iterable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">,</span> <span class="token class-name">Serializable</span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@NonNull</span>
    <span class="token keyword">final</span> <span class="token class-name">T1</span> t1<span class="token punctuation">;</span>
    <span class="token annotation punctuation">@NonNull</span>
    <span class="token keyword">final</span> <span class="token class-name">T2</span> t2<span class="token punctuation">;</span>

    <span class="token class-name">Tuple2</span><span class="token punctuation">(</span><span class="token class-name">T1</span> t1<span class="token punctuation">,</span> <span class="token class-name">T2</span> t2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>t1 <span class="token operator">=</span> <span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">requireNonNull</span><span class="token punctuation">(</span>t1<span class="token punctuation">,</span> <span class="token string">&quot;t1&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>t2 <span class="token operator">=</span> <span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">requireNonNull</span><span class="token punctuation">(</span>t2<span class="token punctuation">,</span> <span class="token string">&quot;t2&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    <span class="token comment">// ...Ignore other code</span>
<span class="token punctuation">}</span>

<span class="token comment">// 这是一个存储三个元素的元组，直接继承 Tuple2 实现，...后续增加存储元素数量的 Tuple 对象也是如此递推</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Tuple3</span><span class="token generics"><span class="token punctuation">&lt;</span>T1<span class="token punctuation">,</span> T2<span class="token punctuation">,</span> T3<span class="token punctuation">&gt;</span></span> <span class="token keyword">extends</span> <span class="token class-name">Tuple2</span><span class="token generics"><span class="token punctuation">&lt;</span>T1<span class="token punctuation">,</span> T2<span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@NonNull</span>
    <span class="token keyword">final</span> <span class="token class-name">T3</span> t3<span class="token punctuation">;</span>

    <span class="token class-name">Tuple3</span><span class="token punctuation">(</span><span class="token class-name">T1</span> t1<span class="token punctuation">,</span> <span class="token class-name">T2</span> t2<span class="token punctuation">,</span> <span class="token class-name">T3</span> t3<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">super</span><span class="token punctuation">(</span>t1<span class="token punctuation">,</span> t2<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>t3 <span class="token operator">=</span> <span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">requireNonNull</span><span class="token punctuation">(</span>t3<span class="token punctuation">,</span> <span class="token string">&quot;t3&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    <span class="token comment">// ...Ignore other code</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>OK，介绍完概念，就该来看看代码实操了，我们构造一个例子，生产两条消息进行消费，然后合并为一条进行输出，也就是数据聚合操作。</p><p>函数定义如下：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@Compenent</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MQHandler</span> <span class="token punctuation">{</span>
    
    <span class="token comment">// 该函数表示接受两个输入（一个 String，一个 Integer）和一个输出（String）</span>
    <span class="token annotation punctuation">@Bean</span>
    <span class="token keyword">public</span> <span class="token class-name">Function</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Tuple2</span><span class="token punctuation">&lt;</span><span class="token class-name">Flux</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span><span class="token punctuation">,</span> <span class="token class-name">Flux</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span><span class="token punctuation">,</span> <span class="token class-name">Flux</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> <span class="token function">multipleInput</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> tuple <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
            <span class="token class-name">Flux</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> t1 <span class="token operator">=</span> tuple<span class="token punctuation">.</span><span class="token function">getT1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">Flux</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> t2 <span class="token operator">=</span> tuple<span class="token punctuation">.</span><span class="token function">getT2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 将两个通道的数据连接在一起</span>
            <span class="token comment">// Flux 与 Mono 两者的方法较多，可查看对象源码或 Project Reactor 文档获取相应信息进一步了解。</span>
            <span class="token keyword">return</span> <span class="token class-name">Flux</span><span class="token punctuation">.</span><span class="token function">combineLatest</span><span class="token punctuation">(</span>t1<span class="token punctuation">,</span> t2<span class="token punctuation">,</span> <span class="token punctuation">(</span>k1<span class="token punctuation">,</span> k2<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> k1 <span class="token operator">+</span> k2<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    <span class="token comment">// 该函数用于消费数据聚合的结果</span>
    <span class="token annotation punctuation">@Bean</span>
    <span class="token keyword">public</span> <span class="token class-name">Consumer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Message</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> <span class="token function">gatherConsumer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> msg <span class="token operator">-&gt;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;数据聚合结果：&quot;</span> <span class="token operator">+</span> msg<span class="token punctuation">.</span><span class="token function">getPayload</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p><strong>NOTE</strong>：multipleInput 函数在服务启动时便会执行一次，是因为 Bean 注册之后会调用一遍将 Function 结果转为 Flux 对象，后续就不会再走这个函数，而是通过 Flux 对象进行数据处理了，想理解原理还是要优先了解 Project Reactor 中 Flux 的使用。</p></blockquote><p>可以看到上面函数定义的输入输出是 <code>Tuple2&lt;Flux&lt;String&gt;, Flux&lt;Integer&gt;&gt;, Flux&lt;String&gt;&gt;</code>，这样会直接取到消息的内容，如果有需要拿到消息头，可以定义成 <code>Tuple2&lt;Flux&lt;Message&lt;String&gt;&gt;, Flux&lt;Message&lt;Integer&gt;&gt;&gt;, Flux&lt;String&gt;&gt;</code>。</p>`,41),b=n("code",null,"index",-1),y=p(`<div class="language-yaml line-numbers-mode" data-ext="yml"><pre class="language-yaml"><code><span class="token key atrule">spring</span><span class="token punctuation">:</span>
  <span class="token key atrule">cloud</span><span class="token punctuation">:</span>
    <span class="token key atrule">stream</span><span class="token punctuation">:</span>
      <span class="token key atrule">bindings</span><span class="token punctuation">:</span>
      	<span class="token comment"># 向该绑定发送的消息就代表输入参数一</span>
        <span class="token key atrule">multipleInput-in-0</span><span class="token punctuation">:</span>
          <span class="token key atrule">destination</span><span class="token punctuation">:</span> multiple<span class="token punctuation">-</span>input<span class="token punctuation">-</span>exchange
          <span class="token key atrule">group</span><span class="token punctuation">:</span> input<span class="token punctuation">-</span>queue
        <span class="token comment"># 向该绑定发送的消息就代表输入参数二</span>
        <span class="token key atrule">multipleInput-in-1</span><span class="token punctuation">:</span>
          <span class="token key atrule">destination</span><span class="token punctuation">:</span> multiple<span class="token punctuation">-</span>input<span class="token punctuation">-</span>exchange
          <span class="token key atrule">group</span><span class="token punctuation">:</span> input<span class="token punctuation">-</span>queue
        <span class="token comment"># 代表输出参数</span>
        <span class="token key atrule">multipleInput-out-0</span><span class="token punctuation">:</span>
          <span class="token key atrule">destination</span><span class="token punctuation">:</span> gather<span class="token punctuation">-</span>consumer<span class="token punctuation">-</span>exchange
        <span class="token comment"># 消费数据聚合结果的绑定</span>
        <span class="token key atrule">gatherConsumer-in-0</span><span class="token punctuation">:</span>
          <span class="token key atrule">destination</span><span class="token punctuation">:</span> gather<span class="token punctuation">-</span>consumer<span class="token punctuation">-</span>exchange
          <span class="token key atrule">group</span><span class="token punctuation">:</span> gather<span class="token punctuation">-</span>consumer<span class="token punctuation">-</span>queue
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>StreamBridge 发送消息时，则是必须向两个输入绑定都发送了消息，才能触发函数执行：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@RestController</span>
<span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">&quot;/demo&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DemoController</span> <span class="token punctuation">{</span>

	<span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">&quot;/send&quot;</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">multipleInput</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Message</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> msg1 <span class="token operator">=</span> <span class="token class-name">MessageBuilder</span><span class="token punctuation">.</span><span class="token function">withPayload</span><span class="token punctuation">(</span><span class="token string">&quot;Hello, multiple in/out args.&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Message</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> msg2 <span class="token operator">=</span> <span class="token class-name">MessageBuilder</span><span class="token punctuation">.</span><span class="token function">withPayload</span><span class="token punctuation">(</span><span class="token number">9527</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 使用多输入通道时，需要向所有输入绑定都发送了消息才会被消费者函数处理</span>
        streamBridge<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token string">&quot;multipleInput-in-0&quot;</span><span class="token punctuation">,</span> msg1<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token comment">// 休眠期间第一条消息不会实际触达，而是要等到两个消息都发出</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;休眠 3 秒.&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">SECONDS</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        streamBridge<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token string">&quot;multipleInput-in-1&quot;</span><span class="token punctuation">,</span> msg2<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>执行结果如下，两条消息内容合并了：</p><figure><img src="`+m+'" alt="控制台信息" tabindex="0" loading="lazy"><figcaption>控制台信息</figcaption></figure>',5),h={href:"https://docs.spring.io/spring-cloud-stream/reference/spring-cloud-stream/producing-and-consuming-messages.html#functions-with-multiple-input-and-output-arguments",target:"_blank",rel:"noopener noreferrer"},x=n("h2",{id:"总结",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#总结","aria-hidden":"true"},"#"),s(" 总结")],-1),f=n("p",null,"关于 Spring Cloud Stream 的概念、功能、使用就介绍到这，相信系列三篇文章看下来大家对 Spring Cloud Stream 的使用也就没有大问题了。在如今的生产项目中，微服务架构、分布式系统大行其道，MQ 的使用早已是家常便饭，而能有这么一款框架适配了如此之多的主流消息中间件，建立统一抽象，简化使用方式，并提供新功能，无疑是给开发者带来颇多帮助，提升了 MQ 使用效率。",-1),w=n("p",null,"当然，Spring Cloud Stream 对于各个消息中间件的适配，最终原理还是基于 Spring 本身对消息中间件的支持与集成，所以还是要求大家对使用的消息中间件本身有一定的理解和使用经验。",-1),S=n("p",null,"OVER!😄",-1),_=n("h2",{id:"参考资料",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#参考资料","aria-hidden":"true"},"#"),s(" 参考资料")],-1),q={href:"https://docs.spring.io/spring-cloud-stream/reference/spring-cloud-stream/overview-partitioning.html",target:"_blank",rel:"noopener noreferrer"},T={href:"https://docs.spring.io/spring-cloud-stream/reference/spring-cloud-stream/producing-and-consuming-messages.html#functions-with-multiple-input-and-output-arguments",target:"_blank",rel:"noopener noreferrer"};function I(C,M){const o=e("RouterLink"),t=e("ExternalLinkIcon");return i(),l("div",null,[g,n("p",null,[s("在第一篇中介绍"),a(o,{to:"/posts/framework/spring/spring_cloud_stream_one.html#BindingName"},{default:u(()=>[s("绑定名称的规则")]),_:1}),s("时，就有提到 "),b,s(" 是绑定的索引，只用于多输入/输出参数的函数，它从 0 开始，有多少个输入/输出参数，就配置多少个绑定，上面函数只定义了两个输入参数和一个输出参数，因此配置应当如下：")]),y,n("p",null,[s("至于多输出参数的函数定义使用，官方文档也已有"),n("a",h,[s("示例"),a(t)]),s("，就不再演示，读者可以自己耍耍。")]),x,f,w,S,_,n("ul",null,[n("li",null,[n("p",null,[s("官方文档："),n("a",q,[s("分区"),a(t)])])]),n("li",null,[n("p",null,[s("官方文档："),n("a",T,[s("具有多输入/输出参数的函数"),a(t)])])])])])}const B=c(v,[["render",I],["__file","spring_cloud_stream_three.html.vue"]]);export{B as default};
