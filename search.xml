<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>JVM-内存模型</title>
    <url>/2020/07/08/JVM-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="什么是-JVM"><a href="#什么是-JVM" class="headerlink" title="什么是 JVM"></a>什么是 JVM</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>JVM 是 Java Virtual Machine（Java 虚拟机）的缩写，是一种用于计算设备的规范、能够运行 Java 字节码的虚拟机，拥有自己完善的硬体架构，如处理器、堆栈、寄存器等，还具有相应的指令系统。</p>
<p>引入 Java 虚拟机后，Java 语言开发的程序在不同平台上运行时不需要重新编译。JVM屏蔽了与具体操作系统平台相关的信息，使得 Java 程序只需生成在 Java 虚拟机上运行的字节码(.class)，就可以在多种平台上不加修改地运行。对于 JVM，除了 Oracle，也有其它的开源或闭源实现。（摘自<a href="[https://zh.wikipedia.org/wiki/Java%E8%99%9A%E6%8B%9F%E6%9C%BA](https://zh.wikipedia.org/wiki/Java虚拟机)">维基百科</a>）</p>
<h3 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h3><p>Java 是一门可跨平台的语言，但其本身并不能跨平台，而是通过 JVM 来实现。是通过 JVM 将编译好的文件解释成平台系统（Mac、Linux、Windows 等）可执行的机器码，然后系统加以运行，实现<strong>“一次编译，到处运行”</strong>的效果。</p>
<p>学习 JVM，可以围绕四个部分进行：</p>
<ul>
<li>类的加载机制</li>
<li>内存模型</li>
<li>GC 算法、垃圾回收</li>
<li>GC 分析、命令调优</li>
</ul>
<p>本篇着重于 JVM 内存模型的讲解，作为 Java 开发人员，平常或多或少会有这样的疑问，堆内存空间应当设置多大？OOM（OutOfMemoryError）异常到底涉及了运行时数据内存哪块区域？JVM 内存调优从哪里入手？</p>
<p>在理解了 JVM 内存模型后，我们就可以知道，平常编写的 Java 文件信息是如何被 JVM 管理、存放，Java 方法执行时生成的变量、返回结果等 JVM 又是如何操作，堆内存大小如何设置等等。</p>
<h2 id="JVM-内存模型"><a href="#JVM-内存模型" class="headerlink" title="JVM 内存模型"></a>JVM 内存模型</h2><p>Java 程序的开发，并不需要像 C/C++ 开发一样时刻关注内存的释放，而是全权交由 JVM 去管理，JVM 内存模型主要是指运行时内存模型，分为 <strong>线程私有</strong> 和 <strong>线程共享</strong> 数据区两大类：</p>
<ul>
<li>线程私有：程序计数器、虚拟机栈、本地方法栈；</li>
<li>线程共享：Java 堆（Heap）、方法区（包含运行时常量池）。</li>
</ul>
<p>线程私有数据区域生命周期与线程相同，依赖用户线程的启动（结束）而创建（销毁）；<br>线程共享数据区域则随虚拟机的启动（关闭）而创建（销毁）。</p>
<p>JVM 内存模型结构图（<font color="green">绿色</font>共享，<font color="CC6600">橙色</font>私有）：</p>
<img src="/2020/07/08/JVM-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/jvmMemoryModel.jpg" width="800" height="450" alt="JVM内存结构" align="true">

<h3 id="程序计数器（私有）"><a href="#程序计数器（私有）" class="headerlink" title="程序计数器（私有）"></a>程序计数器（私有）</h3><p>程序计数器是一块较小的内存空间，是当前线程所执行的字节码的行号指示器，每个线程都有一个独立的计数器，互不影响。通过该计数器，JVM 解释器就知道下一步要执行的字节码指令位置，而分支、循环、跳转、异常处理、线程恢复等基础功能也都依赖于该计数器来实现。</p>
<p>如果线程正在执行的是一个 Java 方法，则计数器记录的是正在执行的虚拟机字节码指令的地址，若为 Native 方法，则计数器的值为空（Undefined），并且该内存区域是唯一一个在虚拟机中没有规定任何 OOM 异常情况的区域。</p>
<h3 id="虚拟机栈（私有）"><a href="#虚拟机栈（私有）" class="headerlink" title="虚拟机栈（私有）"></a>虚拟机栈（私有）</h3><p>是描述 Java 方法执行的内存模型，每个方法（不含 Native）在执行时都会创建一个栈帧，方法执行过程，就对应着虚拟机栈的入栈到出栈的过程。（现在明白平常用 IDE 调试时点击 Drop Frame 是回退到方法执行前的原因了吧 (●’◡’●)）</p>
<h4 id="栈帧（Stack-Frame）结构"><a href="#栈帧（Stack-Frame）结构" class="headerlink" title="栈帧（Stack Frame）结构"></a>栈帧（Stack Frame）结构</h4><ul>
<li>局部变量表</li>
<li>操作栈</li>
<li>动态链接</li>
<li>方法返回地址</li>
<li>额外附加信息</li>
</ul>
<p>栈帧是用来存储数据和部分过程结果的数据结构，同时也被用来处理动态链接、方法返回值和异常分派（Dispatch Exception）。栈帧随着方法调用而创建，随着方法结束而销毁——无论方法是正常完成还是异常完成（抛出了在方法内未被捕获的异常）都算作方法结束。 </p>
<h4 id="异常（Exception）"><a href="#异常（Exception）" class="headerlink" title="异常（Exception）"></a>异常（Exception）</h4><p>JVM 规范规定该区域有两种异常：</p>
<ul>
<li><strong>StackOverFlowError</strong>：当线程请求栈深度超出虚拟机栈所允许的深度时抛出；</li>
<li><strong>OutOfMemoryError</strong>：当 JVM 动态扩展到无法申请足够内存时抛出。</li>
</ul>
<h3 id="本地方法栈（私有）"><a href="#本地方法栈（私有）" class="headerlink" title="本地方法栈（私有）"></a>本地方法栈（私有）</h3><p>本地方法栈的作用其实与虚拟机栈类似，区别只在于 <strong>本地方法栈是为 Native 方法 服务</strong>，<strong>而虚拟机栈是为 Java 方法 服务</strong>。虚拟机规范中对本地方法栈中的方法使用的语言、方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。有的虚拟机实现也将本地方法栈和虚拟机栈合并，如 HotSpot 虚拟机。</p>
<p>对于异常抛出规范，也与虚拟机栈相同，分别是 <strong>StackOverFlowError</strong> 和 <strong>OutOfMemoryError</strong>。</p>
<h3 id="Java-堆（共享）"><a href="#Java-堆（共享）" class="headerlink" title="Java 堆（共享）"></a>Java 堆（共享）</h3><p>Java 堆（Heap）是 JVM 管理的最大的一块内存，也是 GC（Garbage Collection，垃圾收集）的重点照顾对象，存放的是几乎所有的对象实例和数组数据。（JIT 编译器有栈上分配、标量替换等优化技术的实现导致部分对象实例数据不存在 Java 堆，而是栈内存）</p>
<p>由于主流 JVM 实现对于 GC 采用分代收集算法，因此从 GC 角度来看，Java 堆可分为：</p>
<ul>
<li>新生代（Eden 区、From Servivor 区、To Servivor 区）</li>
<li>老年代</li>
</ul>
<p>可以简单的理解新生代主要是存放新创建的对象，而老年代则是存放生命周期或存活时间较长的对象。并且 JVM 在新生代的 Eden 区开辟了一小块内存区域，即 <strong>分配缓冲区（TLAB - Thread-local allocation buffer，线程私有）</strong>，因为 Java 程序中很多对象都是小对象且用过即丢，不存在线程共享和适合被快速 GC ，所以小对象通常会被 JVM 优先分配在 TLAB 上，好处是分配内存效率高。</p>
<p>（<font color="red">PS：</font>这一部分细节涉及到 JVM GC 的知识内容，所以只是粗略介绍新生代和老年代，后续将会新开一篇专门讲解 GC 的文章，也算是挖个小坑，督促自己再接再厉 O(∩_∩)O 。）</p>
<h4 id="异常（Exception）-1"><a href="#异常（Exception）-1" class="headerlink" title="异常（Exception）"></a>异常（Exception）</h4><p>JVM 规范规定该区域可抛出异常： <strong>OutOfMemoryError</strong>，如果在堆中没有内存完成实例分配，并且堆也无法再扩展时抛出。</p>
<h3 id="方法区（共享）"><a href="#方法区（共享）" class="headerlink" title="方法区（共享）"></a>方法区（共享）</h3><p>方法区主要存放的是虚拟机加载的类信息、常量、静态变量、编译器编译后的代码等，而 GC 在此区域出现频率较低，主要针对的是常量池的回收和类型的卸载，GC 不会在主程序运行期对方法区进行清理，所以容易随着加载的 Class 增多导致类膨胀，从而引发 <strong>OutOfMemoryError</strong> 异常。</p>
<p>方法区也常被称为<strong>“永久代（Permanent Generation）”</strong>，这是因为 <strong>HotSpot 虚拟机（Sun JDK 和 Open JDK 自带的虚拟机实现）</strong>的设计团队选择把 GC 分代收集扩展至方法区（也可以理解为是用永久代方法实现了方法区），从而在 GC 方面与 Java 堆保持一致。</p>
<p>在 Java 8 后，永久代则被替换为<strong>“元空间（Metaspace）”</strong>，当然了，后者依然是基于 HotSpot 虚拟机，两者区别主要在于：<strong>元空间并不在虚拟机中，而是使用本地内存</strong>。因此元空间的大小仅受本地内存限制，基本不存在 OOM 异常问题。并且类的元数据放入本地内存，字符串池和静态变量等则放入到 Java 堆中。</p>
<h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><p>作为方法区的一部分，用于存放编译期生产的各种字面量和符号引用，运行时常量池除了编译期产生的 Class 文件的常量池，还可以在运行期间，将新的常量加入常量池，比如 String 类的 intern() 方法。该区域不会抛出 <strong>OutOfMemoryError</strong> 异常。</p>
<ul>
<li>字面量：与 Java 语言层面的常量概念相近，包含文本字符串、声明为 final 的常量值等；</li>
<li>符号引用：编译语言层面的概念，包括以下三类：<ol>
<li>类和接口的全限定名；</li>
<li>字段的名称和描述符；</li>
<li>方法的名称和描述符。</li>
</ol>
</li>
</ul>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>关于堆、栈内存的大小设置，可以通过 IDE（IDEA、Eclipse）或 Web 容器（Tomcat ）等来配置，可通过下图来了解参数所控制的区域分别是什么。</p>
<p><img src="/2020/07/08/JVM-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/Heap.png" alt="堆栈参数设置参照图"></p>
<p>参数控制：</p>
<ul>
<li>-Xms：设置堆的最小空间大小；</li>
<li>-Xmx：设置堆的最大空间大小；</li>
<li>-XX:NewSize：设置新生代最小空间大小；</li>
<li>-XX:MaxNewSize：设置新生代最大空间大小；</li>
<li>-XX:PermSize：设置永久代最小空间大小；（JDK 8 后无效）</li>
<li>-XX:MaxPermSize：设置永久代最大空间大小；（JDK 8 后无效）</li>
<li>-XX:MetaspaceSize：设置元空间最小空间大小；（JDK 8 后有效）</li>
<li>-XX:MaxMetaspaceSize：设置元空间最大空间大小；（JDK 8 后有效）</li>
<li>-Xss：设置每个线程的堆栈大小。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇主要讲解 JVM 内存结构及其概念，意在让大伙了解 JVM 结构是个什么样子，而了解 JVM 是如何管理内存、如何处理 Java 程序运行所产生的数据，可以启发我们在内存管理、性能分析和调优方面的思维，后续文章将会更深入于 JVM 的其它功能原理。</p>
<p>作为 Java 开发者，想要强化个人的技术，扩展自己的思维，JVM 是一道必须攻破的关卡。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote>
<p>《深入理解Java虚拟机》第2章 / 周志明 / 机械工业出版社<br>《Java虚拟机规范》/ Tim Lindholm Frank Yellin / 机械工业出版社<br>技术博客：<a href="https://www.fangzhipeng.com/javainterview/2019/04/09/jmm.html" target="_blank" rel="noopener">Java 虚拟机：JVM 内存模型</a>，作者：<a href="https://www.fangzhipeng.com/" target="_blank" rel="noopener">方志朋</a></p>
</blockquote>
<h2 id="花絮"><a href="#花絮" class="headerlink" title="花絮"></a>花絮</h2><p>本篇是 JVM 系列文章的第一篇，也是我第一次编写的技术博客，之所以以 JVM 知识为开头，也是因为对于 JVM 的内容一直都是仅凭记忆，就导致容易遗忘，而且很多知识点都是零零散散，没有连结成知识网，也没有做一些知识记录（好像暴露了我懒(ˉ▽￣～) ），加上本人也想通过搭建一个博客网站，来总结自己一路学习的技术和知识，并分享给别人，因此便有了这个开头。</p>
<p>博客的编写，尤其是技术类，要考虑的细节还是挺多，如技术原理、常用实现方式、个人实际使用经验、流行程度、更新迭代等。总的来说，这对于我个人的知识总结能力也大有脾益，对一门新技术，我崇尚的是从不会、到了解掌握、再到能讲解给别人听让别人理解。</p>
<p>路漫漫其修远兮，吾将上下而求索。万事不急，坐下喝杯 Java，咱慢慢学。♪(^∇^*)</p>
]]></content>
      <tags>
        <tag>Java 虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title>聊聊 HashMap</title>
    <url>/2020/07/19/%E8%81%8A%E8%81%8A-hashmap/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Map，Java 三大集合框架之一，JDK1.2 时便已存在，是一个 <code>Key-Value</code>键值对映射的接口，即一个 <code>Key</code>对应一个<code>Value</code>。在日常开发使用中，我们常见的 Map 实现类有：HashMap、Hashtable、TreeMap、LinkedHashMap 等，用以应对不同业务情况下的数据存储与使用。而本篇的主角是 HashMap，让我们来粗浅的聊聊它吧。（注意：本篇 HashMap 的源码和原理讲解全部基于 JDK1.7）</p>
<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>HashMap 是基于哈希表(Hashtable)的 Map 实现类，以<code>Key-Value</code>形式保存数据，<code>Key</code>唯一，<code>Value</code>可重复，并采用 Hash 算法确定<code>Key-Value</code>的存储位置从而保证其进行数据快速存取。类图如下：</p>
<img src="/2020/07/19/%E8%81%8A%E8%81%8A-hashmap/HashMap类图.png" width="500">

<h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>HashMap 的底层结构是 <strong>数组+链表</strong>，是通过计算<code>key</code>的 <code>hash</code> 值来确定数组下标位置，然后将<code>key</code>和<code>value</code>作为 Entry&lt;K,V&gt; 对象进行存储。这里需要注意，是作为 <strong>Entry&lt;K,V&gt;</strong> 对象存储，而不是通过 <code>key</code>确定数组下标后直接存放值。Entry&lt;K,V&gt; 是 Map 的内部接口，本质上是一个映射(键值对)，HashMap 类中对它有一个静态实现，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Entry&lt;K,V&gt; next;  <span class="comment">//链表节点中的下一个 Entry&lt;K,V&gt; 对象</span></span><br><span class="line">    <span class="keyword">int</span> hash;         <span class="comment">//当前 Entry 对象的 hash 值</span></span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    Entry(<span class="keyword">int</span> h, K k, V v, Entry&lt;K,V&gt; n) &#123;</span><br><span class="line">        value = v;</span><br><span class="line">        next = n;</span><br><span class="line">        key = k;</span><br><span class="line">        hash = h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//其它代码省略 ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从源码可以看出，Entry&lt;K,V&gt; 对象保存了<code>key</code>、<code>value</code>、<code>hash值</code>，还保存了当前 Entry&lt;K,V&gt; 对象的下一个 Entry&lt;K,V&gt; 对象：<code>Entry&lt;K,V&gt; next</code>。这也是为什么 HasHMap 结构是数组+链表，数组其实就是 Entry&lt;K,V&gt; 类型数组，而链表则是单向的，每个节点都是一个 Entry&lt;K,V&gt; 对象，并保存了下一个 Entry&lt;K,V&gt; 节点的数据，通过一张图来简单理解下：</p>
<img src="/2020/07/19/%E8%81%8A%E8%81%8A-hashmap/HashMap结构.jpg" width="600" height="400">

<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>HashMap 内部定义的几个主要属性如下：</p>
<ul>
<li><code>transient Entry[] table</code>：Entry&lt;K,V&gt; 对象数组，长度始终保持为 2 的幂次方</li>
<li><code>transient int size</code>：HashMap 已存储的元素数量</li>
<li><code>final float loadFactor</code>：负载因子，默认是 0.75，扩容时使用</li>
<li><code>static final int DEFAULT_INITIAL_CAPACITY</code>：HashMap 的默认初始容量</li>
<li><code>int threshold</code>：阈值，当 HashMap 存储的元素数量达到该值，则会触发扩容操作</li>
<li><code>transient int modCount</code>：记录 HashMap 结构修改的次数，如修改值、重新扩容等</li>
</ul>
<p>HashMap 阈值大小计算为： <strong>capacity(容量) * loadFactor(负载因子) = threshold(阈值)</strong> ，<code>capacity</code>也就是构建 HashMap 时指定的容量大小（不指定则默认为 16）。一旦 HashMap 的 <code>size</code> 超过阈值，就会进行扩容操作，重新调整 HashMap 的大小以便存放更多的元素。</p>
<h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><ul>
<li><code>public int size()</code>：返回 HashMap 的元素数量</li>
<li><code>public boolean isEmpty()</code>：判断 HashMap 是否为空</li>
<li><code>public V put(K key, V value)</code>：存放键值对，即数据元素</li>
<li><code>public V get(Object key)</code>：通过 <code>key</code> 获取 <code>Value</code></li>
<li><code>public V remove(Object key)</code>：通过<code>key</code>删除元素</li>
<li><code>public void clear()</code>：清空 HashMap</li>
<li><code>public boolean containsKey(Object key)</code>：判断传递的<code>key</code>在 HashMap 中是否已存在</li>
<li><code>public boolean containsValue(Object value)</code>：判断传递的<code>value</code>是否已有<code>key</code>进行映射</li>
<li><code>public Set keySet()</code>：获取所有<code>key</code>的 Set 集合</li>
<li><code>public Set&gt; entrySet()</code>：获取所有 Entry&lt;K,V&gt; 的 Set 集合，可以用来遍历 HashMap</li>
</ul>
<h2 id="方法原理"><a href="#方法原理" class="headerlink" title="方法原理"></a>方法原理</h2><p>接下来我们具体看看 HashMap 设值、取值、扩容、复制数据等方法的具体实现是怎么样的。</p>
<h3 id="put-方法实现"><a href="#put-方法实现" class="headerlink" title="put 方法实现"></a>put 方法实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> putForNullKey(value);  <span class="comment">//1.判断 key 是否为 Null，为 Null 直接存放在数组下标 0 的位置</span></span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);  <span class="comment">//2.计算 key 的 hash 值</span></span><br><span class="line">    <span class="keyword">int</span> i = indexFor(hash, table.length);  <span class="comment">//3.通过 hash 值计算数组下标 index</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        <span class="comment">//4.判断 hash 值和 key 值是否相同，相同则覆盖并返回旧值</span></span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    modCount++;  <span class="comment">//5.修改次数 +1</span></span><br><span class="line">    addEntry(hash, key, value, i);  <span class="comment">//6.将 key-value 封装为 Entry 对象并添加，</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);  <span class="comment">// 数组长度-1，按位与计算出下标</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果加入新元素超过阈值，则扩容为原来的2倍大小</span></span><br><span class="line">    <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="keyword">null</span> != table[bucketIndex])) &#123;</span><br><span class="line">        resize(<span class="number">2</span> * table.length);</span><br><span class="line">        hash = (<span class="keyword">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">        bucketIndex = indexFor(hash, table.length);</span><br><span class="line">    &#125;</span><br><span class="line">    createEntry(hash, key, value, bucketIndex);  <span class="comment">// 创建 Entry</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">    <span class="comment">//若 e 不为空，则说明发生 hash 碰撞，将 Entry 插入到链表头，将原有节点(e)作为下一个节点</span></span><br><span class="line">    table[bucketIndex] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">    size++; <span class="comment">//HashMap 元素数量 +1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结下步骤：</p>
<ol>
<li>判断 <code>key</code> 是否为 <code>Null</code>，为 <code>Null</code> 则直接存放到数组下标为 0 的位置；</li>
<li>计算 <code>key</code> 的 hash 值并通过该值确定数组下标位置；</li>
<li>判断 <code>key</code> 是否重复，重复则覆盖并返回旧值；</li>
<li>在 <code>addEntry()</code> 方法判断是否需要扩容，最后将 <code>key-value</code> 封装为 Entry&lt;K,V&gt; 对象保存。</li>
</ol>
<h3 id="get-方法实现"><a href="#get-方法实现" class="headerlink" title="get 方法实现"></a>get 方法实现</h3><p>理解了 <code>put()</code> 方法后，<code>get()</code> 方法就简单多了，直接上源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> getForNullKey();  <span class="comment">//1.判断 key 是否 Null，为空直接获取数组下标为 0 的元素</span></span><br><span class="line">    Entry&lt;K,V&gt; entry = getEntry(key);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span> == entry ? <span class="keyword">null</span> : entry.getValue();  <span class="comment">//三目表达式判断</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getEntry</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hash = (key == <span class="keyword">null</span>) ? <span class="number">0</span> : hash(key);  <span class="comment">//计算 key 的 hash 值</span></span><br><span class="line">    <span class="comment">//2.indexFor() 计算数组下标并循环遍历该下标处的链表节点</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)]; e != <span class="keyword">null</span>;e = e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        <span class="comment">//3.判断是否 hash 值和 key 值是否相同且不为 null，不匹配则循环判断下一节点</span></span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结步骤：</p>
<ol>
<li>判断 <code>key</code>是否 <code>Null</code>，为 <code>Null</code> 直接取数组下标为 0 的元素；</li>
<li>在 <code>getEntry()</code> 方法里计算 <code>key</code> 的 <code>hash</code> 值找到下标然后循环遍历判断 <code>key</code> 的值，存在返回值，不存在则返回 <code>Null</code>。</li>
</ol>
<h3 id="resize-transfer-方法实现"><a href="#resize-transfer-方法实现" class="headerlink" title="resize/transfer 方法实现"></a>resize/transfer 方法实现</h3><p>这两个方法主要是数组扩容和数据复制，在 HashMap 中，这个过程称为 <strong>rehashing</strong>。同样上源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;</span><br><span class="line">    Entry[] oldTable = table;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = oldTable.length;  <span class="comment">//1.获取旧数组长度</span></span><br><span class="line">    <span class="comment">//MAXIMUM_CAPACITY 的值为 1&lt;&lt;30，是 Integer.MAX_VALUE 的一半减1，已经大的夸张，基本不存在扩容情况</span></span><br><span class="line">    <span class="comment">//所以重新设置阈值后直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123; </span><br><span class="line">        threshold = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.创建一个新的数组，大小为原来的2倍</span></span><br><span class="line">    Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];</span><br><span class="line">    <span class="comment">//3.获取是否需要重新计算 hash</span></span><br><span class="line">    <span class="keyword">boolean</span> oldAltHashing = useAltHashing;</span><br><span class="line">    useAltHashing |= sun.misc.VM.isBooted() &amp;&amp;</span><br><span class="line">        (newCapacity &gt;= Holder.ALTERNATIVE_HASHING_THRESHOLD);</span><br><span class="line">    <span class="keyword">boolean</span> rehash = oldAltHashing ^ useAltHashing;</span><br><span class="line">    <span class="comment">//4.扩容的关键方法，旧数组数据复制到新数组</span></span><br><span class="line">    transfer(newTable, rehash);</span><br><span class="line">    table = newTable;</span><br><span class="line">    <span class="comment">//5.重新计算阈值</span></span><br><span class="line">    threshold = (<span class="keyword">int</span>)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable, <span class="keyword">boolean</span> rehash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">    <span class="comment">//遍历旧数组</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">        <span class="comment">//遍历当前节点的链表</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">null</span> != e) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">            <span class="comment">//判断是否需要重新计算 hash</span></span><br><span class="line">            <span class="keyword">if</span> (rehash) &#123;</span><br><span class="line">                e.hash = <span class="keyword">null</span> == e.key ? <span class="number">0</span> : hash(e.key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);  <span class="comment">//计算数组下标</span></span><br><span class="line">            e.next = newTable[i];  <span class="comment">//头插法，链表头部插入，已有的节点往后移作为 next 节点</span></span><br><span class="line">            newTable[i] = e;  <span class="comment">//头部插入</span></span><br><span class="line">            e = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结步骤：</p>
<ol>
<li>创建大小为原来 2 倍的新数组；</li>
<li>在<code>transfer()</code>方法将旧数组数据循环遍历复制到新数组（关键）；</li>
<li>将新数组赋值给 HashMap 的<code>table</code>变量，并重新计算阈值。</li>
</ol>
<p>理解清楚 HashMap 的设值、取值、扩容复制原理后，基本上其它方法实现都可以很容易理解，其它方法则交给童鞋们自己去查看源码啦，这里就不多赘述了。</p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="与-Hashtable-的区别"><a href="#与-Hashtable-的区别" class="headerlink" title="与 Hashtable 的区别"></a>与 Hashtable 的区别</h3><p>这里简单对比下 HashMap 和 Hashtable：</p>
<table>
<thead>
<tr>
<th>HashMap</th>
<th>key 允许为 Null(唯一)</th>
<th>线程不安全</th>
<th>效率较高</th>
<th>继承于 AbstractMap&lt;K,V&gt;</th>
</tr>
</thead>
<tbody><tr>
<td>Hashtable</td>
<td>key 不为空</td>
<td>线程安全</td>
<td>效率较低</td>
<td>继承于 Dictionary&lt;K,V&gt;</td>
</tr>
</tbody></table>
<p>Hashtable 的<code>key</code>不能为空，是因为 <code>put()</code>方法里作了判断，为空直接抛出 NPE 异常；而它之所以是线程安全，通过源码可知是因为内部方法都加上了 <code>Synchronize</code>同步锁，但<code>Synchronize</code>是重量级锁，容易引起线程上下文切换而带来线程调度的开销，因此在多线程并发应用中使用是比较少的，推荐使用 ConcurrentHashMap，其采用的是分段锁，效率比 Hashtable 要高出许多（关于锁机制的问题想了解的童鞋们可以自己搜索相关资料学习下）。</p>
<h3 id="HashMap-死链问题"><a href="#HashMap-死链问题" class="headerlink" title="HashMap 死链问题"></a>HashMap 死链问题</h3><p>HashMap 死链是指在 Java 并发情况下，多线程操作 HashMap 产生 Race Condition(竞用条件)，而此时 HashMap 刚好需要扩容，导致旧数据复制到新数组产生死循环。简单讲就是链表中 A(Entry) 的 next 属性指向 B(Entry)，而 B 的 next 属性又指向 A。</p>
<p>关于死链具体情况，在<a href="https://coolshell.cn/articles/9606.html" target="_blank" rel="noopener"><font color="blue">左耳朵耗子-陈皓的《疫苗：Java HashMap的死循环》</font></a>这篇里讲解的非常清楚，很清晰易懂，童鞋们可以看看了解，并且死链情况在 Java1.8 中已经得到解决，在 1.8 版本开始，HashMap 的结构就变为了 <strong>数组+链表+红黑树</strong>，后续新篇章也会对 1.8 版本的 HashMap 作下介绍讲解。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最后来概括下 HashMap 的工作原理：当通过 <code>put()</code> 方法存值时会调用 <code>key.hashCode()</code> 计算哈希值从而获取数组下标，并将<code>Key-Value</code>作为 Entry&lt;K,V&gt; 对象进行存储，调用<code>get()</code>方法时同样计算<code>key</code>的哈希值然后获取数组下标，然后通过 <code>key.equals()</code>判断值是否相同，最终返回结果。当存值时若元素数量大于阈值<code>threshold</code>则进行扩容，大小为原来的2倍。</p>
<p>在日常开发中，HashMap 数据结构使用是非常频繁的，而且也是面试经典问题，对于 HashMap 的理解掌握，至关重要！</p>
]]></content>
      <tags>
        <tag>HashMap</tag>
        <tag>Java 数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM-类加载机制</title>
    <url>/2020/07/15/jvm-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>在 <a href="https://yudi-corgi.github.io/2020/07/08/JVM-内存模型/"><font color="blue">JVM-内存模型</font></a> 篇已经详细讲解了 JVM 内存模型的结构，如果想先了解 JVM 的内存模型，可以戳一下链接先去看看哦。这一篇，我将着重描述 Java 类加载机制，在 JVM 中类的加载到底经历了哪些过程。</p>
<h2 id="什么是类的加载"><a href="#什么是类的加载" class="headerlink" title="什么是类的加载"></a>什么是类的加载</h2><p>类的加载指的是将类的 <code>.class</code> 文件中的二进制数据读入到内存中，将其放在 JVM 运行时数据区的方法区内，然后在堆区创建一个<code>java.lang.Class</code>对象，用来封装类在方法区内的数据结构。类的加载的最终结果是位于堆区中的 Class 对象，Class 对象封装了类在方法区内的数据结构，并提供了访问方法区内的数据结构的接口。</p>
<p>我们可以简单看张图理解下：</p>
<img src="/2020/07/15/jvm-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/jvm类加载.jpg" alt="JVM类加载" align="center">

<p>从图片我们知道，类加载完毕后，类的数据全部都存放在 JVM 的方法区，堆区只是提供了一个入口去调用相应的对象数据，比如 <code>Class.newInstance()</code>，所以到这里，我们也能理解为什么 Java 对象都存放在堆区的原因。</p>
<p>类加载器并不需要等到某个类被“首次主动使用”时再加载它，JVM 规范允许类加载器在预料某个类将要被使用时就预先加载它，如果在预先加载的过程中遇到了 <code>.class</code> 文件缺失或存在错误，类加载器必须在程序首次主动使用该类时才报告错误（LinkageError 错误），如果这个类一直没有被程序主动使用，那么类加载器就不会报告错误。（此段引用于 <a href="http://www.ityouknow.com/jvm/2017/08/19/class-loading-principle.html" target="_blank" rel="noopener">纯洁的微笑-Java 类加载机制</a>）</p>
<h2 id="类的加载过程"><a href="#类的加载过程" class="headerlink" title="类的加载过程"></a>类的加载过程</h2><p>如下图所示，JVM 类加载主要经历五个部分：加载、连接、初始化、使用、卸载。接下来一一讲解每个部分都做了什么。</p>
<p><img src="/2020/07/15/jvm-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B.jpg" alt="类加载过程"></p>
<h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>加载是类加载过程的第一个阶段，主要是查找并加载类的二进制数据，而这一阶段也就会在堆区生成一个 <code>java.lang.Class</code> 对象，作为入口用于访问该对象在方法区里的数据结构。而且这一步也是可控的，我们可以使用默认的类加载器，也可以自定义类加载器对 Java 文件进行加载（关于 <a href="#jump">类加载器</a> 👈下面有做简单介绍）。</p>
<h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><p>连接细化分下来，其实有三步，分别为以下三个部分：</p>
<h4 id="验证：确保被加载的类的正确性"><a href="#验证：确保被加载的类的正确性" class="headerlink" title="验证：确保被加载的类的正确性"></a>验证：确保被加载的类的正确性</h4><p>这是连接的第一步，判断当前 Class 文件的字节流信息是否符合当前 JVM 规范要求，大致会进行以下四个部分的验证：</p>
<ul>
<li>文件格式验证：验证字节流是否符合 Class 文件格式的规范</li>
<li>元数据验证：对字节码描述的信息进行语义分析，以保证其描述的信息符合 Java 语言规范的要求</li>
<li>字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的</li>
<li>符号引用验证：确保”解析”动作能正确执行</li>
</ul>
<h4 id="准备：为类的静态变量分配内存，并将其初始化为默认值"><a href="#准备：为类的静态变量分配内存，并将其初始化为默认值" class="headerlink" title="准备：为类的静态变量分配内存，并将其初始化为默认值"></a>准备：为类的静态变量分配内存，并将其初始化为默认值</h4><p>这一步主要是在方法区中为类变量分配内存，并初始化类变量的值。</p>
<p>比如声明如下，<code>value</code> 的值在准备阶段会被初始化为 0，而不是 80，即数据类型的默认初始值，实际值的初始化会在 <strong>初始化</strong> 阶段（下面会讲到）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">80</span>;</span><br></pre></td></tr></table></figure>

<p>但如果是下面的声明方式，则会直接赋值为 8080，在编译阶段会为 <code>value</code> 生成 ConstantValue 属性，并在准备阶段赋值为 8080：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> value = <span class="number">8080</span>;</span><br></pre></td></tr></table></figure>



<h4 id="解析：把常量池内的符号引用转换为直接引用"><a href="#解析：把常量池内的符号引用转换为直接引用" class="headerlink" title="解析：把常量池内的符号引用转换为直接引用"></a>解析：把常量池内的符号引用转换为直接引用</h4><p>主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符七类符号引用，符号引用类型常见如下：</p>
<ul>
<li>CONSTANT_Class_info</li>
<li>CONSTANT_Field_info</li>
<li>CONSTANT_Method_info</li>
</ul>
<p><strong>符号引用</strong>：一组符号来描述目标，可以是任何字面量，它与虚拟机实现的布局无关，引用的目标并不一定要已经加载到内存中。各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须是一致的，因为符号引用的字面量形式明确定义在 Java 虚拟机规范的 Class 文件格式中。</p>
<p><strong>直接引用</strong>：就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄，当有了直接引用，就说明引用的目标在内存已经存在。</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>为类的静态变量赋予正确的初始值，JVM 负责对类进行初始化，主要对类变量进行初始化，Java 中为类变量进行初始值设定有两种方式：(1) 声明类变量时指定值；(2) 在静态代码块赋值。</p>
<p><strong>初始化的步骤如下</strong>：</p>
<ol>
<li>假如这个类还没有被加载和连接，则程序先加载并连接该类</li>
<li>假如该类的直接父类还没有被初始化，则先初始化其直接父类</li>
<li>假如类中有初始化语句，则系统依次执行这些初始化语句</li>
</ol>
<p>类初始化其实是执行类构造器方法的过程，编译器会自动收集类中的类变量赋值操作和静态代码块的语句合并而成，并且 JVM 会保证子构造器方法执行前，父类构造器已经执行完毕。如果一个类中既没有类变量也没有静态代码块，那么编译器可以不为这个类生成构造器方法。</p>
<p><strong>而初始化只有在对类的主动使用时才会触发，触发方式大概有以下几种</strong>：</p>
<ul>
<li>创建类的实例，也就是 new 的方式</li>
<li>访问某个类或接口的静态变量，或者对该静态变量赋值</li>
<li>调用类的静态方法反射（如 <code>Class.forName(&quot;com.Test&quot;)</code>）</li>
<li>初始化某个类的子类，则其父类也会被初始化</li>
<li>Java 虚拟机启动时被标明为启动类的类，直接使用 java.exe 命令来运行某个主类</li>
</ul>
<p><strong>不会触发类初始化的情况如下</strong>：</p>
<ul>
<li>通过子类引用父类的静态字段，只会触发父类的初始化，而子类不会初始化</li>
<li>定义数组对象，不会触发该类的初始化</li>
<li>常量在编译期间会存入调用类的常量池，但本质上并没有直接引用定义常量的类，所以也不会触发初始化</li>
<li>通过类名获取 Class 对象（<code>Test.Class</code>），不会触发</li>
<li>通过 <code>Class.forName()</code> 加载指定类时，如果指定参数 <code>initialize</code> 为 false ，不会触发类初 始化，因为该参数是告诉虚拟机是否要对类进行初始化</li>
</ul>
<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a><span id="jump">类加载器</span></h2><p>类加载经过 <strong>初始化</strong> 这一步后，就已经可以正常使用，这个过程走下来，其实在最初的 <strong>加载</strong> 这一步开发者可以控制外，其它都是由 JVM 自行完成。而控制加载过程，则需要使用到类加载器。</p>
<p>我们先简单了解下 JVM 提供的三种类加载器，如下图所示：</p>
<img src="/2020/07/15/jvm-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/类加载器.jpg" width="400" height="300" align="center">

<ul>
<li><strong>启动类加载器(Bootstrap ClassLoader)</strong> ：负责加载 JAVA_HOME\lib 目录中的，或通过 -Xbootclasspath 参数指定路径中的，且被 虚拟机认可（按文件名识别，如 rt.jar）的类。</li>
<li><strong>扩展类加载器(Extension ClassLoader)</strong> ：负责加载 JAVA_HOME\lib\ext 目录中的，或通过 java.ext.dirs 系统变量指定路径中的类库。</li>
<li><strong>应用程序类加载器(Application ClassLoader）</strong>：负责加载用户路径（classpath）上的类库。</li>
</ul>
<h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><p>在上面类加器图中我们可以看到，当一个类加载器收到类加载任务，会先交给其父类加载器去完成，因此最终加载任务都会传递到顶层的启动类加载器，只有当父类加载器无法完成加载任务时，才会尝试执行加载任务。这样子的好处是保证了使用不同的类加载器最终得到的都是同样一个 Object 对象。</p>
<p>而类加载器存在以下机制：</p>
<ul>
<li><strong>全盘负责</strong>：当一个类加载器负责加载某个 Class 时，该 Class 所依赖的和引用的其他 Class 也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入。</li>
<li><strong>父类委托</strong>：先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类。</li>
<li><strong>缓存机制</strong>：缓存机制将会保证所有加载过的 Class 都会被缓存，当程序中需要使用某个 Class 时，类加载器先从缓存区寻找该 Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成 Class 对象，存入缓存区。这就是为什么修改了 Class 后，必须重启 JVM，程序的修改才会生效。</li>
</ul>
<h3 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h3><p>当然，如果有需要，我们也可以自定义类加载器，只要 <strong>继承 ClassLoader 并重写其 loadClass() 方法</strong>，然后编写加载的具体逻辑代码即可。但这里有个要注意的点，如果直接重写 <strong>loadClass()</strong> 方法，有可能会破坏原本的双亲委派模型哦，具体如何避免该问题，就得查看浏览下 <strong>loadClass()</strong> 方法的源码了，在兴趣的伙伴们可以去看看哦。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇主要讲解 JVM 类加载机制，意在让读者明白 Java 文件编写后 JVM 是如何处理并正确使用，并理解类加载器的执行机制。当然本篇并不算全面细致的讲解，也有忽略的细节，如 <strong>连接-验证</strong> 步骤若是反复验证影响了加载效率该如何做，启动类加载器无法被 Java 程序直接引用等问题。</p>
<p>但事无巨细，很多问题都是在某些情况下触发，都是要读者们在实际应用中去注意、发现并解决这些问题，久而久之，不仅问题解决了，还能更深入的理解其核心原理。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote>
<p>《深入理解Java虚拟机》第7章 / 周志明 / 机械工业出版社</p>
</blockquote>
]]></content>
      <tags>
        <tag>Java 虚拟机</tag>
      </tags>
  </entry>
</search>
